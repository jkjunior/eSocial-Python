#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Wed Oct 10 14:18:14 2018 by generateDS.py version 2.29.24.
# Python 3.6.5 (default, May 11 2018, 13:30:17)  [GCC 7.3.0]
#
# Command line options:
#   ('-o', 'classes/evtCS.py')
#   ('-s', 'classes/evtCSSub.py')
#   ('--super', 'evtCS')
#
# Command line arguments:
#   /home/joao/Documents/teste_xsd/xsd/evtCS.xsd
#
# Command line:
#   /home/joao/Documents/teste_xsd/dkuhlman-generateds-60c208fd6e8d/generateDS.py -o "classes/evtCS.py" -s "classes/evtCSSub.py" --super="evtCS" /home/joao/Documents/teste_xsd/xsd/evtCS.xsd
#
# Current working directory (os.getcwd()):
#   teste_xsd
#

import sys
import re as re_
import base64
import datetime as datetime_
import warnings as warnings_
try:
    from lxml import etree as etree_
except ImportError:
    from xml.etree import ElementTree as etree_


Validate_simpletypes_ = True
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

def parsexmlstring_(instring, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    element = etree_.fromstring(instring, parser=parser, **kwargs)
    return element

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for a example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ImportError:
    GenerateDSNamespaceDefs_ = {}

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:
    
    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (
                    time_parts[0], "{}".format(micro_seconds).rjust(6, "0"), )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.
            # The target value must match at least one of the patterns
            # in order for the test to succeed.
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    mo = re_.search(patterns2, target)
                    if mo is not None and len(mo.group(0)) == len(target):
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.iteritems()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                if ExternalEncoding:
                    encoding = ExternalEncoding
                else:
                    encoding = 'utf-8'
                return instring.encode(encoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result
        def __eq__(self, other):
            if type(self) != type(other):
                return False
            return self.__dict__ == other.__dict__
        def __ne__(self, other):
            return not self.__eq__(other)
    
    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = ''
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name,
                pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
            optional=0, child_attrs=None, choice=None):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs
    def get_child_attrs(self): return self.child_attrs
    def set_choice(self, choice): self.choice = choice
    def get_choice(self): return self.choice
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class eSocial(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, evtCS=None, Signature=None):
        self.original_tagname_ = None
        self.evtCS = evtCS
        self.Signature = Signature
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, eSocial)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if eSocial.subclass:
            return eSocial.subclass(*args_, **kwargs_)
        else:
            return eSocial(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_evtCS(self): return self.evtCS
    def set_evtCS(self, evtCS): self.evtCS = evtCS
    def get_Signature(self): return self.Signature
    def set_Signature(self, Signature): self.Signature = Signature
    def hasContent_(self):
        if (
            self.evtCS is not None or
            self.Signature is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='eSocial', namespacedef_=' xmlns:ds="http://www.w3.org/2000/09/xmldsig#" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('eSocial')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='eSocial')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='eSocial', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='eSocial'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='eSocial', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.evtCS is not None:
            self.evtCS.export(outfile, level, namespaceprefix_, name_='evtCS', pretty_print=pretty_print)
        if self.Signature is not None:
            self.Signature.export(outfile, level, namespaceprefix_='ds:', name_='Signature', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'evtCS':
            obj_ = evtCSType.factory()
            obj_.build(child_)
            self.evtCS = obj_
            obj_.original_tagname_ = 'evtCS'
        elif nodeName_ == 'Signature':
            obj_ = SignatureType.factory()
            obj_.build(child_)
            self.Signature = obj_
            obj_.original_tagname_ = 'Signature'
# end class eSocial


class TEmpregador(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, tpInsc=None, nrInsc=None):
        self.original_tagname_ = None
        self.tpInsc = tpInsc
        self.validate_tpInscType12(self.tpInsc)
        self.nrInsc = nrInsc
        self.validate_nrInscType13(self.nrInsc)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TEmpregador)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TEmpregador.subclass:
            return TEmpregador.subclass(*args_, **kwargs_)
        else:
            return TEmpregador(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tpInsc(self): return self.tpInsc
    def set_tpInsc(self, tpInsc): self.tpInsc = tpInsc
    def get_nrInsc(self): return self.nrInsc
    def set_nrInsc(self, nrInsc): self.nrInsc = nrInsc
    def validate_tpInscType12(self, value):
        # Validate type tpInscType12, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_tpInscType12_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_tpInscType12_patterns_, ))
    validate_tpInscType12_patterns_ = [['^\\d$']]
    def validate_nrInscType13(self, value):
        # Validate type nrInscType13, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_nrInscType13_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_nrInscType13_patterns_, ))
    validate_nrInscType13_patterns_ = [['^\\d{8,15}$']]
    def hasContent_(self):
        if (
            self.tpInsc is not None or
            self.nrInsc is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='TEmpregador', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TEmpregador')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TEmpregador')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='TEmpregador', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TEmpregador'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='TEmpregador', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tpInsc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tpInsc>%s</tpInsc>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.tpInsc), input_name='tpInsc')), eol_))
        if self.nrInsc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<nrInsc>%s</nrInsc>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.nrInsc), input_name='nrInsc')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tpInsc':
            tpInsc_ = child_.text
            tpInsc_ = self.gds_validate_string(tpInsc_, node, 'tpInsc')
            self.tpInsc = tpInsc_
            # validate type tpInscType12
            self.validate_tpInscType12(self.tpInsc)
        elif nodeName_ == 'nrInsc':
            nrInsc_ = child_.text
            nrInsc_ = self.gds_validate_string(nrInsc_, node, 'nrInsc')
            self.nrInsc = nrInsc_
            # validate type nrInscType13
            self.validate_nrInscType13(self.nrInsc)
# end class TEmpregador


class SignatureType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Id=None, SignedInfo=None, SignatureValue=None, KeyInfo=None, Object=None):
        self.original_tagname_ = None
        self.Id = _cast(None, Id)
        self.SignedInfo = SignedInfo
        self.SignatureValue = SignatureValue
        self.KeyInfo = KeyInfo
        if Object is None:
            self.Object = []
        else:
            self.Object = Object
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SignatureType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SignatureType.subclass:
            return SignatureType.subclass(*args_, **kwargs_)
        else:
            return SignatureType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SignedInfo(self): return self.SignedInfo
    def set_SignedInfo(self, SignedInfo): self.SignedInfo = SignedInfo
    def get_SignatureValue(self): return self.SignatureValue
    def set_SignatureValue(self, SignatureValue): self.SignatureValue = SignatureValue
    def get_KeyInfo(self): return self.KeyInfo
    def set_KeyInfo(self, KeyInfo): self.KeyInfo = KeyInfo
    def get_Object(self): return self.Object
    def set_Object(self, Object): self.Object = Object
    def add_Object(self, value): self.Object.append(value)
    def insert_Object_at(self, index, value): self.Object.insert(index, value)
    def replace_Object_at(self, index, value): self.Object[index] = value
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def hasContent_(self):
        if (
            self.SignedInfo is not None or
            self.SignatureValue is not None or
            self.KeyInfo is not None or
            self.Object
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ds:', name_='SignatureType', namespacedef_=' xmlns:ds="http://www.w3.org/2000/09/xmldsig#" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SignatureType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SignatureType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='ds:', name_='SignatureType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ds:', name_='SignatureType'):
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (quote_attrib(self.Id), ))
    def exportChildren(self, outfile, level, namespaceprefix_='ds:', name_='SignatureType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SignedInfo is not None:
            self.SignedInfo.export(outfile, level, namespaceprefix_='ds:', name_='SignedInfo', pretty_print=pretty_print)
        if self.SignatureValue is not None:
            self.SignatureValue.export(outfile, level, namespaceprefix_='ds:', name_='SignatureValue', pretty_print=pretty_print)
        if self.KeyInfo is not None:
            self.KeyInfo.export(outfile, level, namespaceprefix_='ds:', name_='KeyInfo', pretty_print=pretty_print)
        for Object_ in self.Object:
            Object_.export(outfile, level, namespaceprefix_='ds:', name_='Object', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SignedInfo':
            obj_ = SignedInfoType.factory()
            obj_.build(child_)
            self.SignedInfo = obj_
            obj_.original_tagname_ = 'SignedInfo'
        elif nodeName_ == 'SignatureValue':
            obj_ = SignatureValueType.factory()
            obj_.build(child_)
            self.SignatureValue = obj_
            obj_.original_tagname_ = 'SignatureValue'
        elif nodeName_ == 'KeyInfo':
            obj_ = KeyInfoType.factory()
            obj_.build(child_)
            self.KeyInfo = obj_
            obj_.original_tagname_ = 'KeyInfo'
        elif nodeName_ == 'Object':
            obj_ = ObjectType.factory()
            obj_.build(child_)
            self.Object.append(obj_)
            obj_.original_tagname_ = 'Object'
# end class SignatureType


class SignatureValueType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Id=None, valueOf_=None):
        self.original_tagname_ = None
        self.Id = _cast(None, Id)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SignatureValueType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SignatureValueType.subclass:
            return SignatureValueType.subclass(*args_, **kwargs_)
        else:
            return SignatureValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ds:', name_='SignatureValueType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SignatureValueType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SignatureValueType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_='ds:', name_='SignatureValueType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ds:', name_='SignatureValueType'):
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (quote_attrib(self.Id), ))
    def exportChildren(self, outfile, level, namespaceprefix_='ds:', name_='SignatureValueType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SignatureValueType


class SignedInfoType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Id=None, CanonicalizationMethod=None, SignatureMethod=None, Reference=None):
        self.original_tagname_ = None
        self.Id = _cast(None, Id)
        self.CanonicalizationMethod = CanonicalizationMethod
        self.SignatureMethod = SignatureMethod
        if Reference is None:
            self.Reference = []
        else:
            self.Reference = Reference
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SignedInfoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SignedInfoType.subclass:
            return SignedInfoType.subclass(*args_, **kwargs_)
        else:
            return SignedInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CanonicalizationMethod(self): return self.CanonicalizationMethod
    def set_CanonicalizationMethod(self, CanonicalizationMethod): self.CanonicalizationMethod = CanonicalizationMethod
    def get_SignatureMethod(self): return self.SignatureMethod
    def set_SignatureMethod(self, SignatureMethod): self.SignatureMethod = SignatureMethod
    def get_Reference(self): return self.Reference
    def set_Reference(self, Reference): self.Reference = Reference
    def add_Reference(self, value): self.Reference.append(value)
    def insert_Reference_at(self, index, value): self.Reference.insert(index, value)
    def replace_Reference_at(self, index, value): self.Reference[index] = value
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def hasContent_(self):
        if (
            self.CanonicalizationMethod is not None or
            self.SignatureMethod is not None or
            self.Reference
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ds:', name_='SignedInfoType', namespacedef_=' xmlns:ds="http://www.w3.org/2000/09/xmldsig#" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SignedInfoType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SignedInfoType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='ds:', name_='SignedInfoType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ds:', name_='SignedInfoType'):
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (quote_attrib(self.Id), ))
    def exportChildren(self, outfile, level, namespaceprefix_='ds:', name_='SignedInfoType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CanonicalizationMethod is not None:
            self.CanonicalizationMethod.export(outfile, level, namespaceprefix_='ds:', name_='CanonicalizationMethod', pretty_print=pretty_print)
        if self.SignatureMethod is not None:
            self.SignatureMethod.export(outfile, level, namespaceprefix_='ds:', name_='SignatureMethod', pretty_print=pretty_print)
        for Reference_ in self.Reference:
            Reference_.export(outfile, level, namespaceprefix_='ds:', name_='Reference', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CanonicalizationMethod':
            obj_ = CanonicalizationMethodType.factory()
            obj_.build(child_)
            self.CanonicalizationMethod = obj_
            obj_.original_tagname_ = 'CanonicalizationMethod'
        elif nodeName_ == 'SignatureMethod':
            obj_ = SignatureMethodType.factory()
            obj_.build(child_)
            self.SignatureMethod = obj_
            obj_.original_tagname_ = 'SignatureMethod'
        elif nodeName_ == 'Reference':
            obj_ = ReferenceType.factory()
            obj_.build(child_)
            self.Reference.append(obj_)
            obj_.original_tagname_ = 'Reference'
# end class SignedInfoType


class CanonicalizationMethodType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Algorithm=None, anytypeobjs_=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.Algorithm = _cast(None, Algorithm)
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CanonicalizationMethodType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CanonicalizationMethodType.subclass:
            return CanonicalizationMethodType.subclass(*args_, **kwargs_)
        else:
            return CanonicalizationMethodType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_Algorithm(self): return self.Algorithm
    def set_Algorithm(self, Algorithm): self.Algorithm = Algorithm
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.anytypeobjs_ or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ds:', name_='CanonicalizationMethodType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CanonicalizationMethodType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CanonicalizationMethodType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='ds:', name_='CanonicalizationMethodType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ds:', name_='CanonicalizationMethodType'):
        if self.Algorithm is not None and 'Algorithm' not in already_processed:
            already_processed.add('Algorithm')
            outfile.write(' Algorithm=%s' % (quote_attrib(self.Algorithm), ))
    def exportChildren(self, outfile, level, namespaceprefix_='ds:', name_='CanonicalizationMethodType', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespaceprefix_, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Algorithm', node)
        if value is not None and 'Algorithm' not in already_processed:
            already_processed.add('Algorithm')
            self.Algorithm = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == '':
            obj_ = __ANY__.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, '', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_'):
              self.add_(obj_.value)
            elif hasattr(self, 'set_'):
              self.set_(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class CanonicalizationMethodType


class SignatureMethodType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Algorithm=None, HMACOutputLength=None, anytypeobjs_=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.Algorithm = _cast(None, Algorithm)
        self.HMACOutputLength = HMACOutputLength
        self.validate_HMACOutputLengthType(self.HMACOutputLength)
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SignatureMethodType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SignatureMethodType.subclass:
            return SignatureMethodType.subclass(*args_, **kwargs_)
        else:
            return SignatureMethodType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_HMACOutputLength(self): return self.HMACOutputLength
    def set_HMACOutputLength(self, HMACOutputLength): self.HMACOutputLength = HMACOutputLength
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_Algorithm(self): return self.Algorithm
    def set_Algorithm(self, Algorithm): self.Algorithm = Algorithm
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_HMACOutputLengthType(self, value):
        # Validate type HMACOutputLengthType, a restriction on integer.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.HMACOutputLength is not None or
            self.anytypeobjs_ or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ds:', name_='SignatureMethodType', namespacedef_=' xmlns:ds="http://www.w3.org/2000/09/xmldsig#" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SignatureMethodType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SignatureMethodType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='ds:', name_='SignatureMethodType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ds:', name_='SignatureMethodType'):
        if self.Algorithm is not None and 'Algorithm' not in already_processed:
            already_processed.add('Algorithm')
            outfile.write(' Algorithm=%s' % (quote_attrib(self.Algorithm), ))
    def exportChildren(self, outfile, level, namespaceprefix_='ds:', name_='SignatureMethodType', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.HMACOutputLength is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ds:HMACOutputLength>%s</ds:HMACOutputLength>%s' % (self.gds_format_integer(self.HMACOutputLength, input_name='HMACOutputLength'), eol_))
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespaceprefix_, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Algorithm', node)
        if value is not None and 'Algorithm' not in already_processed:
            already_processed.add('Algorithm')
            self.Algorithm = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'HMACOutputLength' and child_.text is not None:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeInteger, 'HMACOutputLength', ival_)
            self.content_.append(obj_)
        elif nodeName_ == '':
            obj_ = __ANY__.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, '', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_'):
              self.add_(obj_.value)
            elif hasattr(self, 'set_'):
              self.set_(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class SignatureMethodType


class ReferenceType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Id=None, URI=None, Type=None, Transforms=None, DigestMethod=None, DigestValue=None):
        self.original_tagname_ = None
        self.Id = _cast(None, Id)
        self.URI = _cast(None, URI)
        self.Type = _cast(None, Type)
        self.Transforms = Transforms
        self.DigestMethod = DigestMethod
        self.DigestValue = DigestValue
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReferenceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReferenceType.subclass:
            return ReferenceType.subclass(*args_, **kwargs_)
        else:
            return ReferenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Transforms(self): return self.Transforms
    def set_Transforms(self, Transforms): self.Transforms = Transforms
    def get_DigestMethod(self): return self.DigestMethod
    def set_DigestMethod(self, DigestMethod): self.DigestMethod = DigestMethod
    def get_DigestValue(self): return self.DigestValue
    def set_DigestValue(self, DigestValue): self.DigestValue = DigestValue
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def get_URI(self): return self.URI
    def set_URI(self, URI): self.URI = URI
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def hasContent_(self):
        if (
            self.Transforms is not None or
            self.DigestMethod is not None or
            self.DigestValue is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ds:', name_='ReferenceType', namespacedef_=' xmlns:ds="http://www.w3.org/2000/09/xmldsig#" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ReferenceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ReferenceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='ds:', name_='ReferenceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ds:', name_='ReferenceType'):
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (quote_attrib(self.Id), ))
        if self.URI is not None and 'URI' not in already_processed:
            already_processed.add('URI')
            outfile.write(' URI=%s' % (quote_attrib(self.URI), ))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            outfile.write(' Type=%s' % (quote_attrib(self.Type), ))
    def exportChildren(self, outfile, level, namespaceprefix_='ds:', name_='ReferenceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Transforms is not None:
            self.Transforms.export(outfile, level, namespaceprefix_='ds:', name_='Transforms', pretty_print=pretty_print)
        if self.DigestMethod is not None:
            self.DigestMethod.export(outfile, level, namespaceprefix_='ds:', name_='DigestMethod', pretty_print=pretty_print)
        if self.DigestValue is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ds:DigestValue>%s</ds:DigestValue>%s' % (self.gds_format_base64(self.DigestValue, input_name='DigestValue'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
        value = find_attr_value_('URI', node)
        if value is not None and 'URI' not in already_processed:
            already_processed.add('URI')
            self.URI = value
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            self.Type = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Transforms':
            obj_ = TransformsType.factory()
            obj_.build(child_)
            self.Transforms = obj_
            obj_.original_tagname_ = 'Transforms'
        elif nodeName_ == 'DigestMethod':
            obj_ = DigestMethodType.factory()
            obj_.build(child_)
            self.DigestMethod = obj_
            obj_.original_tagname_ = 'DigestMethod'
        elif nodeName_ == 'DigestValue':
            sval_ = child_.text
            if sval_ is not None:
                try:
                    bval_ = base64.b64decode(sval_)
                except (TypeError, ValueError) as exp:
                    raise_parse_error(child_, 'requires base64 encoded string: %s' % exp)
                bval_ = self.gds_validate_base64(bval_, node, 'DigestValue')
            else:
                bval_ = None
            self.DigestValue = bval_
# end class ReferenceType


class TransformsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Transform=None):
        self.original_tagname_ = None
        if Transform is None:
            self.Transform = []
        else:
            self.Transform = Transform
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TransformsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TransformsType.subclass:
            return TransformsType.subclass(*args_, **kwargs_)
        else:
            return TransformsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Transform(self): return self.Transform
    def set_Transform(self, Transform): self.Transform = Transform
    def add_Transform(self, value): self.Transform.append(value)
    def insert_Transform_at(self, index, value): self.Transform.insert(index, value)
    def replace_Transform_at(self, index, value): self.Transform[index] = value
    def hasContent_(self):
        if (
            self.Transform
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ds:', name_='TransformsType', namespacedef_=' xmlns:ds="http://www.w3.org/2000/09/xmldsig#" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TransformsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TransformsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='ds:', name_='TransformsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ds:', name_='TransformsType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='ds:', name_='TransformsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Transform_ in self.Transform:
            Transform_.export(outfile, level, namespaceprefix_='ds:', name_='Transform', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Transform':
            obj_ = TransformType.factory()
            obj_.build(child_)
            self.Transform.append(obj_)
            obj_.original_tagname_ = 'Transform'
# end class TransformsType


class TransformType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Algorithm=None, anytypeobjs_=None, XPath=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.Algorithm = _cast(None, Algorithm)
        self.anytypeobjs_ = anytypeobjs_
        if XPath is None:
            self.XPath = []
        else:
            self.XPath = XPath
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TransformType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TransformType.subclass:
            return TransformType.subclass(*args_, **kwargs_)
        else:
            return TransformType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def get_XPath(self): return self.XPath
    def set_XPath(self, XPath): self.XPath = XPath
    def add_XPath(self, value): self.XPath.append(value)
    def insert_XPath_at(self, index, value): self.XPath.insert(index, value)
    def replace_XPath_at(self, index, value): self.XPath[index] = value
    def get_Algorithm(self): return self.Algorithm
    def set_Algorithm(self, Algorithm): self.Algorithm = Algorithm
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.anytypeobjs_ is not None or
            self.XPath or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ds:', name_='TransformType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TransformType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TransformType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='ds:', name_='TransformType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ds:', name_='TransformType'):
        if self.Algorithm is not None and 'Algorithm' not in already_processed:
            already_processed.add('Algorithm')
            outfile.write(' Algorithm=%s' % (quote_attrib(self.Algorithm), ))
    def exportChildren(self, outfile, level, namespaceprefix_='ds:', name_='TransformType', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for XPath_ in self.XPath:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ds:XPath>%s</ds:XPath>%s' % (self.gds_encode(self.gds_format_string(quote_xml(XPath_), input_name='XPath')), eol_))
        if self.anytypeobjs_ is not None:
            self.anytypeobjs_.export(outfile, level, namespaceprefix_, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Algorithm', node)
        if value is not None and 'Algorithm' not in already_processed:
            already_processed.add('Algorithm')
            self.Algorithm = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == '':
            obj_ = __ANY__.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, '', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_'):
              self.add_(obj_.value)
            elif hasattr(self, 'set_'):
              self.set_(obj_.value)
        elif nodeName_ == 'XPath' and child_.text is not None:
            valuestr_ = child_.text
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'XPath', valuestr_)
            self.content_.append(obj_)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class TransformType


class DigestMethodType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Algorithm=None, anytypeobjs_=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.Algorithm = _cast(None, Algorithm)
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DigestMethodType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DigestMethodType.subclass:
            return DigestMethodType.subclass(*args_, **kwargs_)
        else:
            return DigestMethodType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_Algorithm(self): return self.Algorithm
    def set_Algorithm(self, Algorithm): self.Algorithm = Algorithm
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.anytypeobjs_ or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ds:', name_='DigestMethodType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DigestMethodType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DigestMethodType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='ds:', name_='DigestMethodType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ds:', name_='DigestMethodType'):
        if self.Algorithm is not None and 'Algorithm' not in already_processed:
            already_processed.add('Algorithm')
            outfile.write(' Algorithm=%s' % (quote_attrib(self.Algorithm), ))
    def exportChildren(self, outfile, level, namespaceprefix_='ds:', name_='DigestMethodType', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespaceprefix_, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Algorithm', node)
        if value is not None and 'Algorithm' not in already_processed:
            already_processed.add('Algorithm')
            self.Algorithm = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == '':
            obj_ = __ANY__.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, '', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_'):
              self.add_(obj_.value)
            elif hasattr(self, 'set_'):
              self.set_(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class DigestMethodType


class KeyInfoType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Id=None, KeyName=None, KeyValue=None, RetrievalMethod=None, X509Data=None, PGPData=None, SPKIData=None, MgmtData=None, anytypeobjs_=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.Id = _cast(None, Id)
        if KeyName is None:
            self.KeyName = []
        else:
            self.KeyName = KeyName
        if KeyValue is None:
            self.KeyValue = []
        else:
            self.KeyValue = KeyValue
        if RetrievalMethod is None:
            self.RetrievalMethod = []
        else:
            self.RetrievalMethod = RetrievalMethod
        if X509Data is None:
            self.X509Data = []
        else:
            self.X509Data = X509Data
        if PGPData is None:
            self.PGPData = []
        else:
            self.PGPData = PGPData
        if SPKIData is None:
            self.SPKIData = []
        else:
            self.SPKIData = SPKIData
        if MgmtData is None:
            self.MgmtData = []
        else:
            self.MgmtData = MgmtData
        self.anytypeobjs_ = anytypeobjs_
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, KeyInfoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if KeyInfoType.subclass:
            return KeyInfoType.subclass(*args_, **kwargs_)
        else:
            return KeyInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_KeyName(self): return self.KeyName
    def set_KeyName(self, KeyName): self.KeyName = KeyName
    def add_KeyName(self, value): self.KeyName.append(value)
    def insert_KeyName_at(self, index, value): self.KeyName.insert(index, value)
    def replace_KeyName_at(self, index, value): self.KeyName[index] = value
    def get_KeyValue(self): return self.KeyValue
    def set_KeyValue(self, KeyValue): self.KeyValue = KeyValue
    def add_KeyValue(self, value): self.KeyValue.append(value)
    def insert_KeyValue_at(self, index, value): self.KeyValue.insert(index, value)
    def replace_KeyValue_at(self, index, value): self.KeyValue[index] = value
    def get_RetrievalMethod(self): return self.RetrievalMethod
    def set_RetrievalMethod(self, RetrievalMethod): self.RetrievalMethod = RetrievalMethod
    def add_RetrievalMethod(self, value): self.RetrievalMethod.append(value)
    def insert_RetrievalMethod_at(self, index, value): self.RetrievalMethod.insert(index, value)
    def replace_RetrievalMethod_at(self, index, value): self.RetrievalMethod[index] = value
    def get_X509Data(self): return self.X509Data
    def set_X509Data(self, X509Data): self.X509Data = X509Data
    def add_X509Data(self, value): self.X509Data.append(value)
    def insert_X509Data_at(self, index, value): self.X509Data.insert(index, value)
    def replace_X509Data_at(self, index, value): self.X509Data[index] = value
    def get_PGPData(self): return self.PGPData
    def set_PGPData(self, PGPData): self.PGPData = PGPData
    def add_PGPData(self, value): self.PGPData.append(value)
    def insert_PGPData_at(self, index, value): self.PGPData.insert(index, value)
    def replace_PGPData_at(self, index, value): self.PGPData[index] = value
    def get_SPKIData(self): return self.SPKIData
    def set_SPKIData(self, SPKIData): self.SPKIData = SPKIData
    def add_SPKIData(self, value): self.SPKIData.append(value)
    def insert_SPKIData_at(self, index, value): self.SPKIData.insert(index, value)
    def replace_SPKIData_at(self, index, value): self.SPKIData[index] = value
    def get_MgmtData(self): return self.MgmtData
    def set_MgmtData(self, MgmtData): self.MgmtData = MgmtData
    def add_MgmtData(self, value): self.MgmtData.append(value)
    def insert_MgmtData_at(self, index, value): self.MgmtData.insert(index, value)
    def replace_MgmtData_at(self, index, value): self.MgmtData[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.KeyName or
            self.KeyValue or
            self.RetrievalMethod or
            self.X509Data or
            self.PGPData or
            self.SPKIData or
            self.MgmtData or
            self.anytypeobjs_ is not None or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ds:', name_='KeyInfoType', namespacedef_=' xmlns:ds="http://www.w3.org/2000/09/xmldsig#" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('KeyInfoType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='KeyInfoType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='ds:', name_='KeyInfoType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ds:', name_='KeyInfoType'):
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (quote_attrib(self.Id), ))
    def exportChildren(self, outfile, level, namespaceprefix_='ds:', name_='KeyInfoType', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for KeyName_ in self.KeyName:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ds:KeyName>%s</ds:KeyName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(KeyName_), input_name='KeyName')), eol_))
        for KeyValue_ in self.KeyValue:
            KeyValue_.export(outfile, level, namespaceprefix_='ds:', name_='KeyValue', pretty_print=pretty_print)
        for RetrievalMethod_ in self.RetrievalMethod:
            RetrievalMethod_.export(outfile, level, namespaceprefix_='ds:', name_='RetrievalMethod', pretty_print=pretty_print)
        for X509Data_ in self.X509Data:
            X509Data_.export(outfile, level, namespaceprefix_='ds:', name_='X509Data', pretty_print=pretty_print)
        for PGPData_ in self.PGPData:
            PGPData_.export(outfile, level, namespaceprefix_='ds:', name_='PGPData', pretty_print=pretty_print)
        for SPKIData_ in self.SPKIData:
            SPKIData_.export(outfile, level, namespaceprefix_='ds:', name_='SPKIData', pretty_print=pretty_print)
        for MgmtData_ in self.MgmtData:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ds:MgmtData>%s</ds:MgmtData>%s' % (self.gds_encode(self.gds_format_string(quote_xml(MgmtData_), input_name='MgmtData')), eol_))
        if self.anytypeobjs_ is not None:
            self.anytypeobjs_.export(outfile, level, namespaceprefix_, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'KeyName' and child_.text is not None:
            valuestr_ = child_.text
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'KeyName', valuestr_)
            self.content_.append(obj_)
        elif nodeName_ == 'KeyValue':
            obj_ = KeyValueType.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'KeyValue', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_KeyValue'):
              self.add_KeyValue(obj_.value)
            elif hasattr(self, 'set_KeyValue'):
              self.set_KeyValue(obj_.value)
        elif nodeName_ == 'RetrievalMethod':
            obj_ = RetrievalMethodType.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'RetrievalMethod', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_RetrievalMethod'):
              self.add_RetrievalMethod(obj_.value)
            elif hasattr(self, 'set_RetrievalMethod'):
              self.set_RetrievalMethod(obj_.value)
        elif nodeName_ == 'X509Data':
            obj_ = X509DataType.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'X509Data', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_X509Data'):
              self.add_X509Data(obj_.value)
            elif hasattr(self, 'set_X509Data'):
              self.set_X509Data(obj_.value)
        elif nodeName_ == 'PGPData':
            obj_ = PGPDataType.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'PGPData', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_PGPData'):
              self.add_PGPData(obj_.value)
            elif hasattr(self, 'set_PGPData'):
              self.set_PGPData(obj_.value)
        elif nodeName_ == 'SPKIData':
            obj_ = SPKIDataType.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'SPKIData', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_SPKIData'):
              self.add_SPKIData(obj_.value)
            elif hasattr(self, 'set_SPKIData'):
              self.set_SPKIData(obj_.value)
        elif nodeName_ == 'MgmtData' and child_.text is not None:
            valuestr_ = child_.text
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'MgmtData', valuestr_)
            self.content_.append(obj_)
        elif nodeName_ == '':
            obj_ = __ANY__.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, '', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_'):
              self.add_(obj_.value)
            elif hasattr(self, 'set_'):
              self.set_(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class KeyInfoType


class KeyValueType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DSAKeyValue=None, RSAKeyValue=None, anytypeobjs_=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.DSAKeyValue = DSAKeyValue
        self.RSAKeyValue = RSAKeyValue
        self.anytypeobjs_ = anytypeobjs_
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, KeyValueType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if KeyValueType.subclass:
            return KeyValueType.subclass(*args_, **kwargs_)
        else:
            return KeyValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DSAKeyValue(self): return self.DSAKeyValue
    def set_DSAKeyValue(self, DSAKeyValue): self.DSAKeyValue = DSAKeyValue
    def get_RSAKeyValue(self): return self.RSAKeyValue
    def set_RSAKeyValue(self, RSAKeyValue): self.RSAKeyValue = RSAKeyValue
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.DSAKeyValue is not None or
            self.RSAKeyValue is not None or
            self.anytypeobjs_ is not None or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ds:', name_='KeyValueType', namespacedef_=' xmlns:ds="http://www.w3.org/2000/09/xmldsig#" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('KeyValueType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='KeyValueType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='ds:', name_='KeyValueType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ds:', name_='KeyValueType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='ds:', name_='KeyValueType', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DSAKeyValue is not None:
            self.DSAKeyValue.export(outfile, level, namespaceprefix_='ds:', name_='DSAKeyValue', pretty_print=pretty_print)
        if self.RSAKeyValue is not None:
            self.RSAKeyValue.export(outfile, level, namespaceprefix_='ds:', name_='RSAKeyValue', pretty_print=pretty_print)
        if self.anytypeobjs_ is not None:
            self.anytypeobjs_.export(outfile, level, namespaceprefix_, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DSAKeyValue':
            obj_ = DSAKeyValueType.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'DSAKeyValue', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_DSAKeyValue'):
              self.add_DSAKeyValue(obj_.value)
            elif hasattr(self, 'set_DSAKeyValue'):
              self.set_DSAKeyValue(obj_.value)
        elif nodeName_ == 'RSAKeyValue':
            obj_ = RSAKeyValueType.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'RSAKeyValue', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_RSAKeyValue'):
              self.add_RSAKeyValue(obj_.value)
            elif hasattr(self, 'set_RSAKeyValue'):
              self.set_RSAKeyValue(obj_.value)
        elif nodeName_ == '':
            obj_ = __ANY__.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, '', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_'):
              self.add_(obj_.value)
            elif hasattr(self, 'set_'):
              self.set_(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class KeyValueType


class RetrievalMethodType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, URI=None, Type=None, Transforms=None):
        self.original_tagname_ = None
        self.URI = _cast(None, URI)
        self.Type = _cast(None, Type)
        self.Transforms = Transforms
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RetrievalMethodType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RetrievalMethodType.subclass:
            return RetrievalMethodType.subclass(*args_, **kwargs_)
        else:
            return RetrievalMethodType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Transforms(self): return self.Transforms
    def set_Transforms(self, Transforms): self.Transforms = Transforms
    def get_URI(self): return self.URI
    def set_URI(self, URI): self.URI = URI
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def hasContent_(self):
        if (
            self.Transforms is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ds:', name_='RetrievalMethodType', namespacedef_=' xmlns:ds="http://www.w3.org/2000/09/xmldsig#" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RetrievalMethodType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RetrievalMethodType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='ds:', name_='RetrievalMethodType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ds:', name_='RetrievalMethodType'):
        if self.URI is not None and 'URI' not in already_processed:
            already_processed.add('URI')
            outfile.write(' URI=%s' % (quote_attrib(self.URI), ))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            outfile.write(' Type=%s' % (quote_attrib(self.Type), ))
    def exportChildren(self, outfile, level, namespaceprefix_='ds:', name_='RetrievalMethodType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Transforms is not None:
            self.Transforms.export(outfile, level, namespaceprefix_='ds:', name_='Transforms', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('URI', node)
        if value is not None and 'URI' not in already_processed:
            already_processed.add('URI')
            self.URI = value
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            self.Type = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Transforms':
            obj_ = TransformsType.factory()
            obj_.build(child_)
            self.Transforms = obj_
            obj_.original_tagname_ = 'Transforms'
# end class RetrievalMethodType


class X509DataType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, X509IssuerSerial=None, X509SKI=None, X509SubjectName=None, X509Certificate=None, X509CRL=None, anytypeobjs_=None):
        self.original_tagname_ = None
        if X509IssuerSerial is None:
            self.X509IssuerSerial = []
        else:
            self.X509IssuerSerial = X509IssuerSerial
        if X509SKI is None:
            self.X509SKI = []
        else:
            self.X509SKI = X509SKI
        if X509SubjectName is None:
            self.X509SubjectName = []
        else:
            self.X509SubjectName = X509SubjectName
        if X509Certificate is None:
            self.X509Certificate = []
        else:
            self.X509Certificate = X509Certificate
        if X509CRL is None:
            self.X509CRL = []
        else:
            self.X509CRL = X509CRL
        self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, X509DataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if X509DataType.subclass:
            return X509DataType.subclass(*args_, **kwargs_)
        else:
            return X509DataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_X509IssuerSerial(self): return self.X509IssuerSerial
    def set_X509IssuerSerial(self, X509IssuerSerial): self.X509IssuerSerial = X509IssuerSerial
    def add_X509IssuerSerial(self, value): self.X509IssuerSerial.append(value)
    def insert_X509IssuerSerial_at(self, index, value): self.X509IssuerSerial.insert(index, value)
    def replace_X509IssuerSerial_at(self, index, value): self.X509IssuerSerial[index] = value
    def get_X509SKI(self): return self.X509SKI
    def set_X509SKI(self, X509SKI): self.X509SKI = X509SKI
    def add_X509SKI(self, value): self.X509SKI.append(value)
    def insert_X509SKI_at(self, index, value): self.X509SKI.insert(index, value)
    def replace_X509SKI_at(self, index, value): self.X509SKI[index] = value
    def get_X509SubjectName(self): return self.X509SubjectName
    def set_X509SubjectName(self, X509SubjectName): self.X509SubjectName = X509SubjectName
    def add_X509SubjectName(self, value): self.X509SubjectName.append(value)
    def insert_X509SubjectName_at(self, index, value): self.X509SubjectName.insert(index, value)
    def replace_X509SubjectName_at(self, index, value): self.X509SubjectName[index] = value
    def get_X509Certificate(self): return self.X509Certificate
    def set_X509Certificate(self, X509Certificate): self.X509Certificate = X509Certificate
    def add_X509Certificate(self, value): self.X509Certificate.append(value)
    def insert_X509Certificate_at(self, index, value): self.X509Certificate.insert(index, value)
    def replace_X509Certificate_at(self, index, value): self.X509Certificate[index] = value
    def get_X509CRL(self): return self.X509CRL
    def set_X509CRL(self, X509CRL): self.X509CRL = X509CRL
    def add_X509CRL(self, value): self.X509CRL.append(value)
    def insert_X509CRL_at(self, index, value): self.X509CRL.insert(index, value)
    def replace_X509CRL_at(self, index, value): self.X509CRL[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def hasContent_(self):
        if (
            self.X509IssuerSerial or
            self.X509SKI or
            self.X509SubjectName or
            self.X509Certificate or
            self.X509CRL or
            self.anytypeobjs_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ds:', name_='X509DataType', namespacedef_=' xmlns:ds="http://www.w3.org/2000/09/xmldsig#" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('X509DataType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='X509DataType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='ds:', name_='X509DataType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ds:', name_='X509DataType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='ds:', name_='X509DataType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for X509IssuerSerial_ in self.X509IssuerSerial:
            X509IssuerSerial_.export(outfile, level, namespaceprefix_, name_='X509IssuerSerial', pretty_print=pretty_print)
        for X509SKI_ in self.X509SKI:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ds:X509SKI>%s</ds:X509SKI>%s' % (self.gds_encode(self.gds_format_string(quote_xml(X509SKI_), input_name='X509SKI')), eol_))
        for X509SubjectName_ in self.X509SubjectName:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ds:X509SubjectName>%s</ds:X509SubjectName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(X509SubjectName_), input_name='X509SubjectName')), eol_))
        for X509Certificate_ in self.X509Certificate:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ds:X509Certificate>%s</ds:X509Certificate>%s' % (self.gds_encode(self.gds_format_string(quote_xml(X509Certificate_), input_name='X509Certificate')), eol_))
        for X509CRL_ in self.X509CRL:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ds:X509CRL>%s</ds:X509CRL>%s' % (self.gds_encode(self.gds_format_string(quote_xml(X509CRL_), input_name='X509CRL')), eol_))
        if self.anytypeobjs_ is not None:
            self.anytypeobjs_.export(outfile, level, namespaceprefix_, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'X509IssuerSerial':
            obj_ = X509IssuerSerialType.factory()
            obj_.build(child_)
            self.X509IssuerSerial.append(obj_)
            obj_.original_tagname_ = 'X509IssuerSerial'
        elif nodeName_ == 'X509SKI':
            X509SKI_ = child_.text
            X509SKI_ = self.gds_validate_string(X509SKI_, node, 'X509SKI')
            self.X509SKI.append(X509SKI_)
        elif nodeName_ == 'X509SubjectName':
            X509SubjectName_ = child_.text
            X509SubjectName_ = self.gds_validate_string(X509SubjectName_, node, 'X509SubjectName')
            self.X509SubjectName.append(X509SubjectName_)
        elif nodeName_ == 'X509Certificate':
            X509Certificate_ = child_.text
            X509Certificate_ = self.gds_validate_string(X509Certificate_, node, 'X509Certificate')
            self.X509Certificate.append(X509Certificate_)
        elif nodeName_ == 'X509CRL':
            X509CRL_ = child_.text
            X509CRL_ = self.gds_validate_string(X509CRL_, node, 'X509CRL')
            self.X509CRL.append(X509CRL_)
        else:
            obj_ = self.gds_build_any(child_, 'X509DataType')
            if obj_ is not None:
                self.set_anytypeobjs_(obj_)
# end class X509DataType


class X509IssuerSerialType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, X509IssuerName=None, X509SerialNumber=None):
        self.original_tagname_ = None
        self.X509IssuerName = X509IssuerName
        self.X509SerialNumber = X509SerialNumber
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, X509IssuerSerialType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if X509IssuerSerialType.subclass:
            return X509IssuerSerialType.subclass(*args_, **kwargs_)
        else:
            return X509IssuerSerialType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_X509IssuerName(self): return self.X509IssuerName
    def set_X509IssuerName(self, X509IssuerName): self.X509IssuerName = X509IssuerName
    def get_X509SerialNumber(self): return self.X509SerialNumber
    def set_X509SerialNumber(self, X509SerialNumber): self.X509SerialNumber = X509SerialNumber
    def hasContent_(self):
        if (
            self.X509IssuerName is not None or
            self.X509SerialNumber is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ds:', name_='X509IssuerSerialType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('X509IssuerSerialType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='X509IssuerSerialType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='ds:', name_='X509IssuerSerialType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ds:', name_='X509IssuerSerialType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='ds:', name_='X509IssuerSerialType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.X509IssuerName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ds:X509IssuerName>%s</ds:X509IssuerName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.X509IssuerName), input_name='X509IssuerName')), eol_))
        if self.X509SerialNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ds:X509SerialNumber>%s</ds:X509SerialNumber>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.X509SerialNumber), input_name='X509SerialNumber')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'X509IssuerName':
            X509IssuerName_ = child_.text
            X509IssuerName_ = self.gds_validate_string(X509IssuerName_, node, 'X509IssuerName')
            self.X509IssuerName = X509IssuerName_
        elif nodeName_ == 'X509SerialNumber':
            X509SerialNumber_ = child_.text
            X509SerialNumber_ = self.gds_validate_string(X509SerialNumber_, node, 'X509SerialNumber')
            self.X509SerialNumber = X509SerialNumber_
# end class X509IssuerSerialType


class PGPDataType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, PGPKeyID=None, PGPKeyPacket=None, anytypeobjs_=None):
        self.original_tagname_ = None
        self.PGPKeyID = PGPKeyID
        self.PGPKeyPacket = PGPKeyPacket
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PGPDataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PGPDataType.subclass:
            return PGPDataType.subclass(*args_, **kwargs_)
        else:
            return PGPDataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PGPKeyID(self): return self.PGPKeyID
    def set_PGPKeyID(self, PGPKeyID): self.PGPKeyID = PGPKeyID
    def get_PGPKeyPacket(self): return self.PGPKeyPacket
    def set_PGPKeyPacket(self, PGPKeyPacket): self.PGPKeyPacket = PGPKeyPacket
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def hasContent_(self):
        if (
            self.PGPKeyID is not None or
            self.PGPKeyPacket is not None or
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ds:', name_='PGPDataType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PGPDataType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PGPDataType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='ds:', name_='PGPDataType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ds:', name_='PGPDataType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='ds:', name_='PGPDataType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PGPKeyID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ds:PGPKeyID>%s</ds:PGPKeyID>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PGPKeyID), input_name='PGPKeyID')), eol_))
        if self.PGPKeyPacket is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ds:PGPKeyPacket>%s</ds:PGPKeyPacket>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PGPKeyPacket), input_name='PGPKeyPacket')), eol_))
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespaceprefix_, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PGPKeyID':
            PGPKeyID_ = child_.text
            PGPKeyID_ = self.gds_validate_string(PGPKeyID_, node, 'PGPKeyID')
            self.PGPKeyID = PGPKeyID_
        elif nodeName_ == 'PGPKeyPacket':
            PGPKeyPacket_ = child_.text
            PGPKeyPacket_ = self.gds_validate_string(PGPKeyPacket_, node, 'PGPKeyPacket')
            self.PGPKeyPacket = PGPKeyPacket_
        else:
            obj_ = self.gds_build_any(child_, 'PGPDataType')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
# end class PGPDataType


class SPKIDataType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, SPKISexp=None, anytypeobjs_=None):
        self.original_tagname_ = None
        if SPKISexp is None:
            self.SPKISexp = []
        else:
            self.SPKISexp = SPKISexp
        self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SPKIDataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SPKIDataType.subclass:
            return SPKIDataType.subclass(*args_, **kwargs_)
        else:
            return SPKIDataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SPKISexp(self): return self.SPKISexp
    def set_SPKISexp(self, SPKISexp): self.SPKISexp = SPKISexp
    def add_SPKISexp(self, value): self.SPKISexp.append(value)
    def insert_SPKISexp_at(self, index, value): self.SPKISexp.insert(index, value)
    def replace_SPKISexp_at(self, index, value): self.SPKISexp[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def hasContent_(self):
        if (
            self.SPKISexp or
            self.anytypeobjs_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ds:', name_='SPKIDataType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SPKIDataType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SPKIDataType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='ds:', name_='SPKIDataType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ds:', name_='SPKIDataType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='ds:', name_='SPKIDataType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for SPKISexp_ in self.SPKISexp:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ds:SPKISexp>%s</ds:SPKISexp>%s' % (self.gds_encode(self.gds_format_string(quote_xml(SPKISexp_), input_name='SPKISexp')), eol_))
        if self.anytypeobjs_ is not None:
            self.anytypeobjs_.export(outfile, level, namespaceprefix_, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SPKISexp':
            SPKISexp_ = child_.text
            SPKISexp_ = self.gds_validate_string(SPKISexp_, node, 'SPKISexp')
            self.SPKISexp.append(SPKISexp_)
        else:
            obj_ = self.gds_build_any(child_, 'SPKIDataType')
            if obj_ is not None:
                self.set_anytypeobjs_(obj_)
# end class SPKIDataType


class ObjectType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Id=None, MimeType=None, Encoding=None, anytypeobjs_=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.Id = _cast(None, Id)
        self.MimeType = _cast(None, MimeType)
        self.Encoding = _cast(None, Encoding)
        self.anytypeobjs_ = anytypeobjs_
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ObjectType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ObjectType.subclass:
            return ObjectType.subclass(*args_, **kwargs_)
        else:
            return ObjectType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def get_MimeType(self): return self.MimeType
    def set_MimeType(self, MimeType): self.MimeType = MimeType
    def get_Encoding(self): return self.Encoding
    def set_Encoding(self, Encoding): self.Encoding = Encoding
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.anytypeobjs_ is not None or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ds:', name_='ObjectType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ObjectType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ObjectType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='ds:', name_='ObjectType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ds:', name_='ObjectType'):
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (quote_attrib(self.Id), ))
        if self.MimeType is not None and 'MimeType' not in already_processed:
            already_processed.add('MimeType')
            outfile.write(' MimeType=%s' % (quote_attrib(self.MimeType), ))
        if self.Encoding is not None and 'Encoding' not in already_processed:
            already_processed.add('Encoding')
            outfile.write(' Encoding=%s' % (quote_attrib(self.Encoding), ))
    def exportChildren(self, outfile, level, namespaceprefix_='ds:', name_='ObjectType', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.anytypeobjs_ is not None:
            self.anytypeobjs_.export(outfile, level, namespaceprefix_, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
        value = find_attr_value_('MimeType', node)
        if value is not None and 'MimeType' not in already_processed:
            already_processed.add('MimeType')
            self.MimeType = value
        value = find_attr_value_('Encoding', node)
        if value is not None and 'Encoding' not in already_processed:
            already_processed.add('Encoding')
            self.Encoding = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == '':
            obj_ = __ANY__.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, '', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_'):
              self.add_(obj_.value)
            elif hasattr(self, 'set_'):
              self.set_(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class ObjectType


class ManifestType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Id=None, Reference=None):
        self.original_tagname_ = None
        self.Id = _cast(None, Id)
        if Reference is None:
            self.Reference = []
        else:
            self.Reference = Reference
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ManifestType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ManifestType.subclass:
            return ManifestType.subclass(*args_, **kwargs_)
        else:
            return ManifestType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Reference(self): return self.Reference
    def set_Reference(self, Reference): self.Reference = Reference
    def add_Reference(self, value): self.Reference.append(value)
    def insert_Reference_at(self, index, value): self.Reference.insert(index, value)
    def replace_Reference_at(self, index, value): self.Reference[index] = value
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def hasContent_(self):
        if (
            self.Reference
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ds:', name_='ManifestType', namespacedef_=' xmlns:ds="http://www.w3.org/2000/09/xmldsig#" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ManifestType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ManifestType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='ds:', name_='ManifestType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ds:', name_='ManifestType'):
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (quote_attrib(self.Id), ))
    def exportChildren(self, outfile, level, namespaceprefix_='ds:', name_='ManifestType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Reference_ in self.Reference:
            Reference_.export(outfile, level, namespaceprefix_='ds:', name_='Reference', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Reference':
            obj_ = ReferenceType.factory()
            obj_.build(child_)
            self.Reference.append(obj_)
            obj_.original_tagname_ = 'Reference'
# end class ManifestType


class SignaturePropertiesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Id=None, SignatureProperty=None):
        self.original_tagname_ = None
        self.Id = _cast(None, Id)
        if SignatureProperty is None:
            self.SignatureProperty = []
        else:
            self.SignatureProperty = SignatureProperty
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SignaturePropertiesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SignaturePropertiesType.subclass:
            return SignaturePropertiesType.subclass(*args_, **kwargs_)
        else:
            return SignaturePropertiesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SignatureProperty(self): return self.SignatureProperty
    def set_SignatureProperty(self, SignatureProperty): self.SignatureProperty = SignatureProperty
    def add_SignatureProperty(self, value): self.SignatureProperty.append(value)
    def insert_SignatureProperty_at(self, index, value): self.SignatureProperty.insert(index, value)
    def replace_SignatureProperty_at(self, index, value): self.SignatureProperty[index] = value
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def hasContent_(self):
        if (
            self.SignatureProperty
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ds:', name_='SignaturePropertiesType', namespacedef_=' xmlns:ds="http://www.w3.org/2000/09/xmldsig#" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SignaturePropertiesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SignaturePropertiesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='ds:', name_='SignaturePropertiesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ds:', name_='SignaturePropertiesType'):
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (quote_attrib(self.Id), ))
    def exportChildren(self, outfile, level, namespaceprefix_='ds:', name_='SignaturePropertiesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for SignatureProperty_ in self.SignatureProperty:
            SignatureProperty_.export(outfile, level, namespaceprefix_='ds:', name_='SignatureProperty', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SignatureProperty':
            obj_ = SignaturePropertyType.factory()
            obj_.build(child_)
            self.SignatureProperty.append(obj_)
            obj_.original_tagname_ = 'SignatureProperty'
# end class SignaturePropertiesType


class SignaturePropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Target=None, Id=None, anytypeobjs_=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.Target = _cast(None, Target)
        self.Id = _cast(None, Id)
        self.anytypeobjs_ = anytypeobjs_
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SignaturePropertyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SignaturePropertyType.subclass:
            return SignaturePropertyType.subclass(*args_, **kwargs_)
        else:
            return SignaturePropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def get_Target(self): return self.Target
    def set_Target(self, Target): self.Target = Target
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.anytypeobjs_ is not None or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ds:', name_='SignaturePropertyType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SignaturePropertyType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SignaturePropertyType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='ds:', name_='SignaturePropertyType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ds:', name_='SignaturePropertyType'):
        if self.Target is not None and 'Target' not in already_processed:
            already_processed.add('Target')
            outfile.write(' Target=%s' % (quote_attrib(self.Target), ))
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (quote_attrib(self.Id), ))
    def exportChildren(self, outfile, level, namespaceprefix_='ds:', name_='SignaturePropertyType', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.anytypeobjs_ is not None:
            self.anytypeobjs_.export(outfile, level, namespaceprefix_, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Target', node)
        if value is not None and 'Target' not in already_processed:
            already_processed.add('Target')
            self.Target = value
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == '':
            obj_ = __ANY__.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, '', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_'):
              self.add_(obj_.value)
            elif hasattr(self, 'set_'):
              self.set_(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class SignaturePropertyType


class DSAKeyValueType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, P=None, Q=None, G=None, Y=None, J=None, Seed=None, PgenCounter=None):
        self.original_tagname_ = None
        self.P = P
        self.validate_CryptoBinary(self.P)
        self.Q = Q
        self.validate_CryptoBinary(self.Q)
        self.G = G
        self.validate_CryptoBinary(self.G)
        self.Y = Y
        self.validate_CryptoBinary(self.Y)
        self.J = J
        self.validate_CryptoBinary(self.J)
        self.Seed = Seed
        self.validate_CryptoBinary(self.Seed)
        self.PgenCounter = PgenCounter
        self.validate_CryptoBinary(self.PgenCounter)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DSAKeyValueType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DSAKeyValueType.subclass:
            return DSAKeyValueType.subclass(*args_, **kwargs_)
        else:
            return DSAKeyValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_P(self): return self.P
    def set_P(self, P): self.P = P
    def get_Q(self): return self.Q
    def set_Q(self, Q): self.Q = Q
    def get_G(self): return self.G
    def set_G(self, G): self.G = G
    def get_Y(self): return self.Y
    def set_Y(self, Y): self.Y = Y
    def get_J(self): return self.J
    def set_J(self, J): self.J = J
    def get_Seed(self): return self.Seed
    def set_Seed(self, Seed): self.Seed = Seed
    def get_PgenCounter(self): return self.PgenCounter
    def set_PgenCounter(self, PgenCounter): self.PgenCounter = PgenCounter
    def validate_CryptoBinary(self, value):
        # Validate type CryptoBinary, a restriction on base64Binary.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.P is not None or
            self.Q is not None or
            self.G is not None or
            self.Y is not None or
            self.J is not None or
            self.Seed is not None or
            self.PgenCounter is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ds:', name_='DSAKeyValueType', namespacedef_=' xmlns:ds="http://www.w3.org/2000/09/xmldsig#" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DSAKeyValueType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DSAKeyValueType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='ds:', name_='DSAKeyValueType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ds:', name_='DSAKeyValueType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='ds:', name_='DSAKeyValueType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.P is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ds:P>%s</ds:P>%s' % (self.gds_format_base64(self.P, input_name='P'), eol_))
        if self.Q is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ds:Q>%s</ds:Q>%s' % (self.gds_format_base64(self.Q, input_name='Q'), eol_))
        if self.G is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ds:G>%s</ds:G>%s' % (self.gds_format_base64(self.G, input_name='G'), eol_))
        if self.Y is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ds:Y>%s</ds:Y>%s' % (self.gds_format_base64(self.Y, input_name='Y'), eol_))
        if self.J is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ds:J>%s</ds:J>%s' % (self.gds_format_base64(self.J, input_name='J'), eol_))
        if self.Seed is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ds:Seed>%s</ds:Seed>%s' % (self.gds_format_base64(self.Seed, input_name='Seed'), eol_))
        if self.PgenCounter is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ds:PgenCounter>%s</ds:PgenCounter>%s' % (self.gds_format_base64(self.PgenCounter, input_name='PgenCounter'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'P':
            sval_ = child_.text
            if sval_ is not None:
                try:
                    bval_ = base64.b64decode(sval_)
                except (TypeError, ValueError) as exp:
                    raise_parse_error(child_, 'requires base64 encoded string: %s' % exp)
                bval_ = self.gds_validate_base64(bval_, node, 'P')
            else:
                bval_ = None
            self.P = bval_
            # validate type CryptoBinary
            self.validate_CryptoBinary(self.P)
        elif nodeName_ == 'Q':
            sval_ = child_.text
            if sval_ is not None:
                try:
                    bval_ = base64.b64decode(sval_)
                except (TypeError, ValueError) as exp:
                    raise_parse_error(child_, 'requires base64 encoded string: %s' % exp)
                bval_ = self.gds_validate_base64(bval_, node, 'Q')
            else:
                bval_ = None
            self.Q = bval_
            # validate type CryptoBinary
            self.validate_CryptoBinary(self.Q)
        elif nodeName_ == 'G':
            sval_ = child_.text
            if sval_ is not None:
                try:
                    bval_ = base64.b64decode(sval_)
                except (TypeError, ValueError) as exp:
                    raise_parse_error(child_, 'requires base64 encoded string: %s' % exp)
                bval_ = self.gds_validate_base64(bval_, node, 'G')
            else:
                bval_ = None
            self.G = bval_
            # validate type CryptoBinary
            self.validate_CryptoBinary(self.G)
        elif nodeName_ == 'Y':
            sval_ = child_.text
            if sval_ is not None:
                try:
                    bval_ = base64.b64decode(sval_)
                except (TypeError, ValueError) as exp:
                    raise_parse_error(child_, 'requires base64 encoded string: %s' % exp)
                bval_ = self.gds_validate_base64(bval_, node, 'Y')
            else:
                bval_ = None
            self.Y = bval_
            # validate type CryptoBinary
            self.validate_CryptoBinary(self.Y)
        elif nodeName_ == 'J':
            sval_ = child_.text
            if sval_ is not None:
                try:
                    bval_ = base64.b64decode(sval_)
                except (TypeError, ValueError) as exp:
                    raise_parse_error(child_, 'requires base64 encoded string: %s' % exp)
                bval_ = self.gds_validate_base64(bval_, node, 'J')
            else:
                bval_ = None
            self.J = bval_
            # validate type CryptoBinary
            self.validate_CryptoBinary(self.J)
        elif nodeName_ == 'Seed':
            sval_ = child_.text
            if sval_ is not None:
                try:
                    bval_ = base64.b64decode(sval_)
                except (TypeError, ValueError) as exp:
                    raise_parse_error(child_, 'requires base64 encoded string: %s' % exp)
                bval_ = self.gds_validate_base64(bval_, node, 'Seed')
            else:
                bval_ = None
            self.Seed = bval_
            # validate type CryptoBinary
            self.validate_CryptoBinary(self.Seed)
        elif nodeName_ == 'PgenCounter':
            sval_ = child_.text
            if sval_ is not None:
                try:
                    bval_ = base64.b64decode(sval_)
                except (TypeError, ValueError) as exp:
                    raise_parse_error(child_, 'requires base64 encoded string: %s' % exp)
                bval_ = self.gds_validate_base64(bval_, node, 'PgenCounter')
            else:
                bval_ = None
            self.PgenCounter = bval_
            # validate type CryptoBinary
            self.validate_CryptoBinary(self.PgenCounter)
# end class DSAKeyValueType


class RSAKeyValueType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Modulus=None, Exponent=None):
        self.original_tagname_ = None
        self.Modulus = Modulus
        self.validate_CryptoBinary(self.Modulus)
        self.Exponent = Exponent
        self.validate_CryptoBinary(self.Exponent)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RSAKeyValueType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RSAKeyValueType.subclass:
            return RSAKeyValueType.subclass(*args_, **kwargs_)
        else:
            return RSAKeyValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Modulus(self): return self.Modulus
    def set_Modulus(self, Modulus): self.Modulus = Modulus
    def get_Exponent(self): return self.Exponent
    def set_Exponent(self, Exponent): self.Exponent = Exponent
    def validate_CryptoBinary(self, value):
        # Validate type CryptoBinary, a restriction on base64Binary.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Modulus is not None or
            self.Exponent is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ds:', name_='RSAKeyValueType', namespacedef_=' xmlns:ds="http://www.w3.org/2000/09/xmldsig#" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RSAKeyValueType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RSAKeyValueType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='ds:', name_='RSAKeyValueType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ds:', name_='RSAKeyValueType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='ds:', name_='RSAKeyValueType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Modulus is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ds:Modulus>%s</ds:Modulus>%s' % (self.gds_format_base64(self.Modulus, input_name='Modulus'), eol_))
        if self.Exponent is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ds:Exponent>%s</ds:Exponent>%s' % (self.gds_format_base64(self.Exponent, input_name='Exponent'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Modulus':
            sval_ = child_.text
            if sval_ is not None:
                try:
                    bval_ = base64.b64decode(sval_)
                except (TypeError, ValueError) as exp:
                    raise_parse_error(child_, 'requires base64 encoded string: %s' % exp)
                bval_ = self.gds_validate_base64(bval_, node, 'Modulus')
            else:
                bval_ = None
            self.Modulus = bval_
            # validate type CryptoBinary
            self.validate_CryptoBinary(self.Modulus)
        elif nodeName_ == 'Exponent':
            sval_ = child_.text
            if sval_ is not None:
                try:
                    bval_ = base64.b64decode(sval_)
                except (TypeError, ValueError) as exp:
                    raise_parse_error(child_, 'requires base64 encoded string: %s' % exp)
                bval_ = self.gds_validate_base64(bval_, node, 'Exponent')
            else:
                bval_ = None
            self.Exponent = bval_
            # validate type CryptoBinary
            self.validate_CryptoBinary(self.Exponent)
# end class RSAKeyValueType


class evtCSType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Id=None, ideEvento=None, ideEmpregador=None, infoCS=None):
        self.original_tagname_ = None
        self.Id = _cast(None, Id)
        self.ideEvento = ideEvento
        self.ideEmpregador = ideEmpregador
        self.infoCS = infoCS
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, evtCSType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if evtCSType.subclass:
            return evtCSType.subclass(*args_, **kwargs_)
        else:
            return evtCSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ideEvento(self): return self.ideEvento
    def set_ideEvento(self, ideEvento): self.ideEvento = ideEvento
    def get_ideEmpregador(self): return self.ideEmpregador
    def set_ideEmpregador(self, ideEmpregador): self.ideEmpregador = ideEmpregador
    def get_infoCS(self): return self.infoCS
    def set_infoCS(self, infoCS): self.infoCS = infoCS
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def hasContent_(self):
        if (
            self.ideEvento is not None or
            self.ideEmpregador is not None or
            self.infoCS is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='evtCSType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('evtCSType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='evtCSType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='evtCSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='evtCSType'):
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Id), input_name='Id')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='evtCSType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ideEvento is not None:
            self.ideEvento.export(outfile, level, namespaceprefix_, name_='ideEvento', pretty_print=pretty_print)
        if self.ideEmpregador is not None:
            self.ideEmpregador.export(outfile, level, namespaceprefix_, name_='ideEmpregador', pretty_print=pretty_print)
        if self.infoCS is not None:
            self.infoCS.export(outfile, level, namespaceprefix_, name_='infoCS', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ideEvento':
            obj_ = ideEventoType.factory()
            obj_.build(child_)
            self.ideEvento = obj_
            obj_.original_tagname_ = 'ideEvento'
        elif nodeName_ == 'ideEmpregador':
            obj_ = TEmpregador.factory()
            obj_.build(child_)
            self.ideEmpregador = obj_
            obj_.original_tagname_ = 'ideEmpregador'
        elif nodeName_ == 'infoCS':
            obj_ = infoCSType.factory()
            obj_.build(child_)
            self.infoCS = obj_
            obj_.original_tagname_ = 'infoCS'
# end class evtCSType


class ideEventoType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, indApuracao=None, perApur=None):
        self.original_tagname_ = None
        self.indApuracao = indApuracao
        self.validate_indApuracaoType(self.indApuracao)
        self.perApur = perApur
        self.validate_perApurType(self.perApur)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ideEventoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ideEventoType.subclass:
            return ideEventoType.subclass(*args_, **kwargs_)
        else:
            return ideEventoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_indApuracao(self): return self.indApuracao
    def set_indApuracao(self, indApuracao): self.indApuracao = indApuracao
    def get_perApur(self): return self.perApur
    def set_perApur(self, perApur): self.perApur = perApur
    def validate_indApuracaoType(self, value):
        # Validate type indApuracaoType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_indApuracaoType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_indApuracaoType_patterns_, ))
    validate_indApuracaoType_patterns_ = [['^\\d$']]
    def validate_perApurType(self, value):
        # Validate type perApurType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 7:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on perApurType' % {"value" : value.encode("utf-8")} )
            if len(value) < 4:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on perApurType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.indApuracao is not None or
            self.perApur is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='ideEventoType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ideEventoType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ideEventoType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='ideEventoType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ideEventoType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='ideEventoType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.indApuracao is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<indApuracao>%s</indApuracao>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.indApuracao), input_name='indApuracao')), eol_))
        if self.perApur is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<perApur>%s</perApur>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.perApur), input_name='perApur')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'indApuracao':
            indApuracao_ = child_.text
            indApuracao_ = self.gds_validate_string(indApuracao_, node, 'indApuracao')
            self.indApuracao = indApuracao_
            # validate type indApuracaoType
            self.validate_indApuracaoType(self.indApuracao)
        elif nodeName_ == 'perApur':
            perApur_ = child_.text
            perApur_ = self.gds_validate_string(perApur_, node, 'perApur')
            self.perApur = perApur_
            # validate type perApurType
            self.validate_perApurType(self.perApur)
# end class ideEventoType


class infoCSType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nrRecArqBase=None, indExistInfo=None, infoCPSeg=None, infoContrib=None, ideEstab=None, infoCRContrib=None):
        self.original_tagname_ = None
        self.nrRecArqBase = nrRecArqBase
        self.validate_nrRecArqBaseType(self.nrRecArqBase)
        self.indExistInfo = indExistInfo
        self.validate_indExistInfoType(self.indExistInfo)
        self.infoCPSeg = infoCPSeg
        self.infoContrib = infoContrib
        if ideEstab is None:
            self.ideEstab = []
        else:
            self.ideEstab = ideEstab
        if infoCRContrib is None:
            self.infoCRContrib = []
        else:
            self.infoCRContrib = infoCRContrib
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infoCSType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infoCSType.subclass:
            return infoCSType.subclass(*args_, **kwargs_)
        else:
            return infoCSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_nrRecArqBase(self): return self.nrRecArqBase
    def set_nrRecArqBase(self, nrRecArqBase): self.nrRecArqBase = nrRecArqBase
    def get_indExistInfo(self): return self.indExistInfo
    def set_indExistInfo(self, indExistInfo): self.indExistInfo = indExistInfo
    def get_infoCPSeg(self): return self.infoCPSeg
    def set_infoCPSeg(self, infoCPSeg): self.infoCPSeg = infoCPSeg
    def get_infoContrib(self): return self.infoContrib
    def set_infoContrib(self, infoContrib): self.infoContrib = infoContrib
    def get_ideEstab(self): return self.ideEstab
    def set_ideEstab(self, ideEstab): self.ideEstab = ideEstab
    def add_ideEstab(self, value): self.ideEstab.append(value)
    def insert_ideEstab_at(self, index, value): self.ideEstab.insert(index, value)
    def replace_ideEstab_at(self, index, value): self.ideEstab[index] = value
    def get_infoCRContrib(self): return self.infoCRContrib
    def set_infoCRContrib(self, infoCRContrib): self.infoCRContrib = infoCRContrib
    def add_infoCRContrib(self, value): self.infoCRContrib.append(value)
    def insert_infoCRContrib_at(self, index, value): self.infoCRContrib.insert(index, value)
    def replace_infoCRContrib_at(self, index, value): self.infoCRContrib[index] = value
    def validate_nrRecArqBaseType(self, value):
        # Validate type nrRecArqBaseType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 40:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on nrRecArqBaseType' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on nrRecArqBaseType' % {"value" : value.encode("utf-8")} )
    def validate_indExistInfoType(self, value):
        # Validate type indExistInfoType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_indExistInfoType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_indExistInfoType_patterns_, ))
    validate_indExistInfoType_patterns_ = [['^\\d$']]
    def hasContent_(self):
        if (
            self.nrRecArqBase is not None or
            self.indExistInfo is not None or
            self.infoCPSeg is not None or
            self.infoContrib is not None or
            self.ideEstab or
            self.infoCRContrib
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='infoCSType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infoCSType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='infoCSType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='infoCSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='infoCSType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='infoCSType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.nrRecArqBase is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<nrRecArqBase>%s</nrRecArqBase>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.nrRecArqBase), input_name='nrRecArqBase')), eol_))
        if self.indExistInfo is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<indExistInfo>%s</indExistInfo>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.indExistInfo), input_name='indExistInfo')), eol_))
        if self.infoCPSeg is not None:
            self.infoCPSeg.export(outfile, level, namespaceprefix_, name_='infoCPSeg', pretty_print=pretty_print)
        if self.infoContrib is not None:
            self.infoContrib.export(outfile, level, namespaceprefix_, name_='infoContrib', pretty_print=pretty_print)
        for ideEstab_ in self.ideEstab:
            ideEstab_.export(outfile, level, namespaceprefix_, name_='ideEstab', pretty_print=pretty_print)
        for infoCRContrib_ in self.infoCRContrib:
            infoCRContrib_.export(outfile, level, namespaceprefix_, name_='infoCRContrib', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'nrRecArqBase':
            nrRecArqBase_ = child_.text
            nrRecArqBase_ = self.gds_validate_string(nrRecArqBase_, node, 'nrRecArqBase')
            self.nrRecArqBase = nrRecArqBase_
            # validate type nrRecArqBaseType
            self.validate_nrRecArqBaseType(self.nrRecArqBase)
        elif nodeName_ == 'indExistInfo':
            indExistInfo_ = child_.text
            indExistInfo_ = self.gds_validate_string(indExistInfo_, node, 'indExistInfo')
            self.indExistInfo = indExistInfo_
            # validate type indExistInfoType
            self.validate_indExistInfoType(self.indExistInfo)
        elif nodeName_ == 'infoCPSeg':
            obj_ = infoCPSegType.factory()
            obj_.build(child_)
            self.infoCPSeg = obj_
            obj_.original_tagname_ = 'infoCPSeg'
        elif nodeName_ == 'infoContrib':
            obj_ = infoContribType.factory()
            obj_.build(child_)
            self.infoContrib = obj_
            obj_.original_tagname_ = 'infoContrib'
        elif nodeName_ == 'ideEstab':
            obj_ = ideEstabType.factory()
            obj_.build(child_)
            self.ideEstab.append(obj_)
            obj_.original_tagname_ = 'ideEstab'
        elif nodeName_ == 'infoCRContrib':
            obj_ = infoCRContribType.factory()
            obj_.build(child_)
            self.infoCRContrib.append(obj_)
            obj_.original_tagname_ = 'infoCRContrib'
# end class infoCSType


class infoCPSegType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, vrDescCP=None, vrCpSeg=None):
        self.original_tagname_ = None
        self.vrDescCP = vrDescCP
        self.validate_vrDescCPType(self.vrDescCP)
        self.vrCpSeg = vrCpSeg
        self.validate_vrCpSegType(self.vrCpSeg)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infoCPSegType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infoCPSegType.subclass:
            return infoCPSegType.subclass(*args_, **kwargs_)
        else:
            return infoCPSegType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vrDescCP(self): return self.vrDescCP
    def set_vrDescCP(self, vrDescCP): self.vrDescCP = vrDescCP
    def get_vrCpSeg(self): return self.vrCpSeg
    def set_vrCpSeg(self, vrCpSeg): self.vrCpSeg = vrCpSeg
    def validate_vrDescCPType(self, value):
        # Validate type vrDescCPType, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 14:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on vrDescCPType' % {"value" : value} )
    def validate_vrCpSegType(self, value):
        # Validate type vrCpSegType, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 14:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on vrCpSegType' % {"value" : value} )
    def hasContent_(self):
        if (
            self.vrDescCP is not None or
            self.vrCpSeg is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='infoCPSegType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infoCPSegType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='infoCPSegType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='infoCPSegType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='infoCPSegType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='infoCPSegType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.vrDescCP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vrDescCP>%s</vrDescCP>%s' % (self.gds_format_float(self.vrDescCP, input_name='vrDescCP'), eol_))
        if self.vrCpSeg is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vrCpSeg>%s</vrCpSeg>%s' % (self.gds_format_float(self.vrCpSeg, input_name='vrCpSeg'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'vrDescCP' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'vrDescCP')
            self.vrDescCP = fval_
            # validate type vrDescCPType
            self.validate_vrDescCPType(self.vrDescCP)
        elif nodeName_ == 'vrCpSeg' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'vrCpSeg')
            self.vrCpSeg = fval_
            # validate type vrCpSegType
            self.validate_vrCpSegType(self.vrCpSeg)
# end class infoCPSegType


class infoContribType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, classTrib=None, infoPJ=None):
        self.original_tagname_ = None
        self.classTrib = classTrib
        self.validate_classTribType(self.classTrib)
        self.infoPJ = infoPJ
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infoContribType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infoContribType.subclass:
            return infoContribType.subclass(*args_, **kwargs_)
        else:
            return infoContribType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_classTrib(self): return self.classTrib
    def set_classTrib(self, classTrib): self.classTrib = classTrib
    def get_infoPJ(self): return self.infoPJ
    def set_infoPJ(self, infoPJ): self.infoPJ = infoPJ
    def validate_classTribType(self, value):
        # Validate type classTribType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) != 2:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on classTribType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.classTrib is not None or
            self.infoPJ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='infoContribType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infoContribType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='infoContribType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='infoContribType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='infoContribType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='infoContribType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.classTrib is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<classTrib>%s</classTrib>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.classTrib), input_name='classTrib')), eol_))
        if self.infoPJ is not None:
            self.infoPJ.export(outfile, level, namespaceprefix_, name_='infoPJ', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'classTrib':
            classTrib_ = child_.text
            classTrib_ = self.gds_validate_string(classTrib_, node, 'classTrib')
            self.classTrib = classTrib_
            # validate type classTribType
            self.validate_classTribType(self.classTrib)
        elif nodeName_ == 'infoPJ':
            obj_ = infoPJType.factory()
            obj_.build(child_)
            self.infoPJ = obj_
            obj_.original_tagname_ = 'infoPJ'
# end class infoContribType


class infoPJType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, indCoop=None, indConstr=None, indSubstPatr=None, percRedContrib=None, infoAtConc=None):
        self.original_tagname_ = None
        self.indCoop = indCoop
        self.validate_indCoopType(self.indCoop)
        self.indConstr = indConstr
        self.validate_indConstrType(self.indConstr)
        self.indSubstPatr = indSubstPatr
        self.validate_indSubstPatrType(self.indSubstPatr)
        self.percRedContrib = percRedContrib
        self.validate_percRedContribType(self.percRedContrib)
        self.infoAtConc = infoAtConc
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infoPJType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infoPJType.subclass:
            return infoPJType.subclass(*args_, **kwargs_)
        else:
            return infoPJType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_indCoop(self): return self.indCoop
    def set_indCoop(self, indCoop): self.indCoop = indCoop
    def get_indConstr(self): return self.indConstr
    def set_indConstr(self, indConstr): self.indConstr = indConstr
    def get_indSubstPatr(self): return self.indSubstPatr
    def set_indSubstPatr(self, indSubstPatr): self.indSubstPatr = indSubstPatr
    def get_percRedContrib(self): return self.percRedContrib
    def set_percRedContrib(self, percRedContrib): self.percRedContrib = percRedContrib
    def get_infoAtConc(self): return self.infoAtConc
    def set_infoAtConc(self, infoAtConc): self.infoAtConc = infoAtConc
    def validate_indCoopType(self, value):
        # Validate type indCoopType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_indCoopType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_indCoopType_patterns_, ))
    validate_indCoopType_patterns_ = [['^\\d$']]
    def validate_indConstrType(self, value):
        # Validate type indConstrType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_indConstrType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_indConstrType_patterns_, ))
    validate_indConstrType_patterns_ = [['^\\d$']]
    def validate_indSubstPatrType(self, value):
        # Validate type indSubstPatrType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_indSubstPatrType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_indSubstPatrType_patterns_, ))
    validate_indSubstPatrType_patterns_ = [['^\\d$']]
    def validate_percRedContribType(self, value):
        # Validate type percRedContribType, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 5:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on percRedContribType' % {"value" : value} )
    def hasContent_(self):
        if (
            self.indCoop is not None or
            self.indConstr is not None or
            self.indSubstPatr is not None or
            self.percRedContrib is not None or
            self.infoAtConc is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='infoPJType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infoPJType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='infoPJType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='infoPJType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='infoPJType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='infoPJType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.indCoop is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<indCoop>%s</indCoop>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.indCoop), input_name='indCoop')), eol_))
        if self.indConstr is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<indConstr>%s</indConstr>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.indConstr), input_name='indConstr')), eol_))
        if self.indSubstPatr is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<indSubstPatr>%s</indSubstPatr>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.indSubstPatr), input_name='indSubstPatr')), eol_))
        if self.percRedContrib is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<percRedContrib>%s</percRedContrib>%s' % (self.gds_format_float(self.percRedContrib, input_name='percRedContrib'), eol_))
        if self.infoAtConc is not None:
            self.infoAtConc.export(outfile, level, namespaceprefix_, name_='infoAtConc', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'indCoop':
            indCoop_ = child_.text
            indCoop_ = self.gds_validate_string(indCoop_, node, 'indCoop')
            self.indCoop = indCoop_
            # validate type indCoopType
            self.validate_indCoopType(self.indCoop)
        elif nodeName_ == 'indConstr':
            indConstr_ = child_.text
            indConstr_ = self.gds_validate_string(indConstr_, node, 'indConstr')
            self.indConstr = indConstr_
            # validate type indConstrType
            self.validate_indConstrType(self.indConstr)
        elif nodeName_ == 'indSubstPatr':
            indSubstPatr_ = child_.text
            indSubstPatr_ = self.gds_validate_string(indSubstPatr_, node, 'indSubstPatr')
            self.indSubstPatr = indSubstPatr_
            # validate type indSubstPatrType
            self.validate_indSubstPatrType(self.indSubstPatr)
        elif nodeName_ == 'percRedContrib' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'percRedContrib')
            self.percRedContrib = fval_
            # validate type percRedContribType
            self.validate_percRedContribType(self.percRedContrib)
        elif nodeName_ == 'infoAtConc':
            obj_ = infoAtConcType.factory()
            obj_.build(child_)
            self.infoAtConc = obj_
            obj_.original_tagname_ = 'infoAtConc'
# end class infoPJType


class infoAtConcType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, fatorMes=None, fator13=None):
        self.original_tagname_ = None
        self.fatorMes = fatorMes
        self.validate_fatorMesType(self.fatorMes)
        self.fator13 = fator13
        self.validate_fator13Type(self.fator13)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infoAtConcType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infoAtConcType.subclass:
            return infoAtConcType.subclass(*args_, **kwargs_)
        else:
            return infoAtConcType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_fatorMes(self): return self.fatorMes
    def set_fatorMes(self, fatorMes): self.fatorMes = fatorMes
    def get_fator13(self): return self.fator13
    def set_fator13(self, fator13): self.fator13 = fator13
    def validate_fatorMesType(self, value):
        # Validate type fatorMesType, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 5:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on fatorMesType' % {"value" : value} )
    def validate_fator13Type(self, value):
        # Validate type fator13Type, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 5:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on fator13Type' % {"value" : value} )
    def hasContent_(self):
        if (
            self.fatorMes is not None or
            self.fator13 is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='infoAtConcType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infoAtConcType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='infoAtConcType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='infoAtConcType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='infoAtConcType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='infoAtConcType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.fatorMes is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<fatorMes>%s</fatorMes>%s' % (self.gds_format_float(self.fatorMes, input_name='fatorMes'), eol_))
        if self.fator13 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<fator13>%s</fator13>%s' % (self.gds_format_float(self.fator13, input_name='fator13'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'fatorMes' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'fatorMes')
            self.fatorMes = fval_
            # validate type fatorMesType
            self.validate_fatorMesType(self.fatorMes)
        elif nodeName_ == 'fator13' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'fator13')
            self.fator13 = fval_
            # validate type fator13Type
            self.validate_fator13Type(self.fator13)
# end class infoAtConcType


class ideEstabType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, tpInsc=None, nrInsc=None, infoEstab=None, ideLotacao=None, basesAquis=None, basesComerc=None, infoCREstab=None):
        self.original_tagname_ = None
        self.tpInsc = tpInsc
        self.validate_tpInscType(self.tpInsc)
        self.nrInsc = nrInsc
        self.validate_nrInscType(self.nrInsc)
        self.infoEstab = infoEstab
        if ideLotacao is None:
            self.ideLotacao = []
        else:
            self.ideLotacao = ideLotacao
        if basesAquis is None:
            self.basesAquis = []
        else:
            self.basesAquis = basesAquis
        if basesComerc is None:
            self.basesComerc = []
        else:
            self.basesComerc = basesComerc
        if infoCREstab is None:
            self.infoCREstab = []
        else:
            self.infoCREstab = infoCREstab
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ideEstabType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ideEstabType.subclass:
            return ideEstabType.subclass(*args_, **kwargs_)
        else:
            return ideEstabType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tpInsc(self): return self.tpInsc
    def set_tpInsc(self, tpInsc): self.tpInsc = tpInsc
    def get_nrInsc(self): return self.nrInsc
    def set_nrInsc(self, nrInsc): self.nrInsc = nrInsc
    def get_infoEstab(self): return self.infoEstab
    def set_infoEstab(self, infoEstab): self.infoEstab = infoEstab
    def get_ideLotacao(self): return self.ideLotacao
    def set_ideLotacao(self, ideLotacao): self.ideLotacao = ideLotacao
    def add_ideLotacao(self, value): self.ideLotacao.append(value)
    def insert_ideLotacao_at(self, index, value): self.ideLotacao.insert(index, value)
    def replace_ideLotacao_at(self, index, value): self.ideLotacao[index] = value
    def get_basesAquis(self): return self.basesAquis
    def set_basesAquis(self, basesAquis): self.basesAquis = basesAquis
    def add_basesAquis(self, value): self.basesAquis.append(value)
    def insert_basesAquis_at(self, index, value): self.basesAquis.insert(index, value)
    def replace_basesAquis_at(self, index, value): self.basesAquis[index] = value
    def get_basesComerc(self): return self.basesComerc
    def set_basesComerc(self, basesComerc): self.basesComerc = basesComerc
    def add_basesComerc(self, value): self.basesComerc.append(value)
    def insert_basesComerc_at(self, index, value): self.basesComerc.insert(index, value)
    def replace_basesComerc_at(self, index, value): self.basesComerc[index] = value
    def get_infoCREstab(self): return self.infoCREstab
    def set_infoCREstab(self, infoCREstab): self.infoCREstab = infoCREstab
    def add_infoCREstab(self, value): self.infoCREstab.append(value)
    def insert_infoCREstab_at(self, index, value): self.infoCREstab.insert(index, value)
    def replace_infoCREstab_at(self, index, value): self.infoCREstab[index] = value
    def validate_tpInscType(self, value):
        # Validate type tpInscType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_tpInscType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_tpInscType_patterns_, ))
    validate_tpInscType_patterns_ = [['^\\d$']]
    def validate_nrInscType(self, value):
        # Validate type nrInscType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_nrInscType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_nrInscType_patterns_, ))
    validate_nrInscType_patterns_ = [['^\\d{8,15}$']]
    def hasContent_(self):
        if (
            self.tpInsc is not None or
            self.nrInsc is not None or
            self.infoEstab is not None or
            self.ideLotacao or
            self.basesAquis or
            self.basesComerc or
            self.infoCREstab
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='ideEstabType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ideEstabType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ideEstabType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='ideEstabType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ideEstabType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='ideEstabType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tpInsc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tpInsc>%s</tpInsc>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.tpInsc), input_name='tpInsc')), eol_))
        if self.nrInsc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<nrInsc>%s</nrInsc>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.nrInsc), input_name='nrInsc')), eol_))
        if self.infoEstab is not None:
            self.infoEstab.export(outfile, level, namespaceprefix_, name_='infoEstab', pretty_print=pretty_print)
        for ideLotacao_ in self.ideLotacao:
            ideLotacao_.export(outfile, level, namespaceprefix_, name_='ideLotacao', pretty_print=pretty_print)
        for basesAquis_ in self.basesAquis:
            basesAquis_.export(outfile, level, namespaceprefix_, name_='basesAquis', pretty_print=pretty_print)
        for basesComerc_ in self.basesComerc:
            basesComerc_.export(outfile, level, namespaceprefix_, name_='basesComerc', pretty_print=pretty_print)
        for infoCREstab_ in self.infoCREstab:
            infoCREstab_.export(outfile, level, namespaceprefix_, name_='infoCREstab', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tpInsc':
            tpInsc_ = child_.text
            tpInsc_ = self.gds_validate_string(tpInsc_, node, 'tpInsc')
            self.tpInsc = tpInsc_
            # validate type tpInscType
            self.validate_tpInscType(self.tpInsc)
        elif nodeName_ == 'nrInsc':
            nrInsc_ = child_.text
            nrInsc_ = self.gds_validate_string(nrInsc_, node, 'nrInsc')
            self.nrInsc = nrInsc_
            # validate type nrInscType
            self.validate_nrInscType(self.nrInsc)
        elif nodeName_ == 'infoEstab':
            obj_ = infoEstabType.factory()
            obj_.build(child_)
            self.infoEstab = obj_
            obj_.original_tagname_ = 'infoEstab'
        elif nodeName_ == 'ideLotacao':
            obj_ = ideLotacaoType.factory()
            obj_.build(child_)
            self.ideLotacao.append(obj_)
            obj_.original_tagname_ = 'ideLotacao'
        elif nodeName_ == 'basesAquis':
            obj_ = basesAquisType.factory()
            obj_.build(child_)
            self.basesAquis.append(obj_)
            obj_.original_tagname_ = 'basesAquis'
        elif nodeName_ == 'basesComerc':
            obj_ = basesComercType.factory()
            obj_.build(child_)
            self.basesComerc.append(obj_)
            obj_.original_tagname_ = 'basesComerc'
        elif nodeName_ == 'infoCREstab':
            obj_ = infoCREstabType.factory()
            obj_.build(child_)
            self.infoCREstab.append(obj_)
            obj_.original_tagname_ = 'infoCREstab'
# end class ideEstabType


class infoEstabType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, cnaePrep=None, aliqRat=None, fap=None, aliqRatAjust=None, infoComplObra=None):
        self.original_tagname_ = None
        self.cnaePrep = cnaePrep
        self.validate_cnaePrepType(self.cnaePrep)
        self.aliqRat = aliqRat
        self.validate_aliqRatType(self.aliqRat)
        self.fap = fap
        self.validate_fapType(self.fap)
        self.aliqRatAjust = aliqRatAjust
        self.validate_aliqRatAjustType(self.aliqRatAjust)
        self.infoComplObra = infoComplObra
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infoEstabType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infoEstabType.subclass:
            return infoEstabType.subclass(*args_, **kwargs_)
        else:
            return infoEstabType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cnaePrep(self): return self.cnaePrep
    def set_cnaePrep(self, cnaePrep): self.cnaePrep = cnaePrep
    def get_aliqRat(self): return self.aliqRat
    def set_aliqRat(self, aliqRat): self.aliqRat = aliqRat
    def get_fap(self): return self.fap
    def set_fap(self, fap): self.fap = fap
    def get_aliqRatAjust(self): return self.aliqRatAjust
    def set_aliqRatAjust(self, aliqRatAjust): self.aliqRatAjust = aliqRatAjust
    def get_infoComplObra(self): return self.infoComplObra
    def set_infoComplObra(self, infoComplObra): self.infoComplObra = infoComplObra
    def validate_cnaePrepType(self, value):
        # Validate type cnaePrepType, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_aliqRatType(self, value):
        # Validate type aliqRatType, a restriction on xs:nonNegativeInteger.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_fapType(self, value):
        # Validate type fapType, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if value < 0.0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on fapType' % {"value" : value} )
            if len(str(value)) >= 5:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on fapType' % {"value" : value} )
    def validate_aliqRatAjustType(self, value):
        # Validate type aliqRatAjustType, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on aliqRatAjustType' % {"value" : value} )
            if len(str(value)) >= 5:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on aliqRatAjustType' % {"value" : value} )
    def hasContent_(self):
        if (
            self.cnaePrep is not None or
            self.aliqRat is not None or
            self.fap is not None or
            self.aliqRatAjust is not None or
            self.infoComplObra is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='infoEstabType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infoEstabType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='infoEstabType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='infoEstabType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='infoEstabType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='infoEstabType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.cnaePrep is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<cnaePrep>%s</cnaePrep>%s' % (self.gds_format_integer(self.cnaePrep, input_name='cnaePrep'), eol_))
        if self.aliqRat is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<aliqRat>%s</aliqRat>%s' % (self.gds_format_integer(self.aliqRat, input_name='aliqRat'), eol_))
        if self.fap is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<fap>%s</fap>%s' % (self.gds_format_float(self.fap, input_name='fap'), eol_))
        if self.aliqRatAjust is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<aliqRatAjust>%s</aliqRatAjust>%s' % (self.gds_format_float(self.aliqRatAjust, input_name='aliqRatAjust'), eol_))
        if self.infoComplObra is not None:
            self.infoComplObra.export(outfile, level, namespaceprefix_, name_='infoComplObra', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cnaePrep' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'cnaePrep')
            self.cnaePrep = ival_
            # validate type cnaePrepType
            self.validate_cnaePrepType(self.cnaePrep)
        elif nodeName_ == 'aliqRat' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'aliqRat')
            self.aliqRat = ival_
            # validate type aliqRatType
            self.validate_aliqRatType(self.aliqRat)
        elif nodeName_ == 'fap' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'fap')
            self.fap = fval_
            # validate type fapType
            self.validate_fapType(self.fap)
        elif nodeName_ == 'aliqRatAjust' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'aliqRatAjust')
            self.aliqRatAjust = fval_
            # validate type aliqRatAjustType
            self.validate_aliqRatAjustType(self.aliqRatAjust)
        elif nodeName_ == 'infoComplObra':
            obj_ = infoComplObraType.factory()
            obj_.build(child_)
            self.infoComplObra = obj_
            obj_.original_tagname_ = 'infoComplObra'
# end class infoEstabType


class infoComplObraType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, indSubstPatrObra=None):
        self.original_tagname_ = None
        self.indSubstPatrObra = indSubstPatrObra
        self.validate_indSubstPatrObraType(self.indSubstPatrObra)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infoComplObraType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infoComplObraType.subclass:
            return infoComplObraType.subclass(*args_, **kwargs_)
        else:
            return infoComplObraType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_indSubstPatrObra(self): return self.indSubstPatrObra
    def set_indSubstPatrObra(self, indSubstPatrObra): self.indSubstPatrObra = indSubstPatrObra
    def validate_indSubstPatrObraType(self, value):
        # Validate type indSubstPatrObraType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_indSubstPatrObraType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_indSubstPatrObraType_patterns_, ))
    validate_indSubstPatrObraType_patterns_ = [['^\\d$']]
    def hasContent_(self):
        if (
            self.indSubstPatrObra is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='infoComplObraType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infoComplObraType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='infoComplObraType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='infoComplObraType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='infoComplObraType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='infoComplObraType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.indSubstPatrObra is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<indSubstPatrObra>%s</indSubstPatrObra>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.indSubstPatrObra), input_name='indSubstPatrObra')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'indSubstPatrObra':
            indSubstPatrObra_ = child_.text
            indSubstPatrObra_ = self.gds_validate_string(indSubstPatrObra_, node, 'indSubstPatrObra')
            self.indSubstPatrObra = indSubstPatrObra_
            # validate type indSubstPatrObraType
            self.validate_indSubstPatrObraType(self.indSubstPatrObra)
# end class infoComplObraType


class ideLotacaoType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, codLotacao=None, fpas=None, codTercs=None, codTercsSusp=None, infoTercSusp=None, infoEmprParcial=None, dadosOpPort=None, basesRemun=None, basesAvNPort=None, infoSubstPatrOpPort=None):
        self.original_tagname_ = None
        self.codLotacao = codLotacao
        self.validate_codLotacaoType(self.codLotacao)
        self.fpas = fpas
        self.validate_fpasType(self.fpas)
        self.codTercs = codTercs
        self.validate_codTercsType(self.codTercs)
        self.codTercsSusp = codTercsSusp
        self.validate_codTercsSuspType(self.codTercsSusp)
        if infoTercSusp is None:
            self.infoTercSusp = []
        else:
            self.infoTercSusp = infoTercSusp
        self.infoEmprParcial = infoEmprParcial
        self.dadosOpPort = dadosOpPort
        if basesRemun is None:
            self.basesRemun = []
        else:
            self.basesRemun = basesRemun
        self.basesAvNPort = basesAvNPort
        if infoSubstPatrOpPort is None:
            self.infoSubstPatrOpPort = []
        else:
            self.infoSubstPatrOpPort = infoSubstPatrOpPort
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ideLotacaoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ideLotacaoType.subclass:
            return ideLotacaoType.subclass(*args_, **kwargs_)
        else:
            return ideLotacaoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_codLotacao(self): return self.codLotacao
    def set_codLotacao(self, codLotacao): self.codLotacao = codLotacao
    def get_fpas(self): return self.fpas
    def set_fpas(self, fpas): self.fpas = fpas
    def get_codTercs(self): return self.codTercs
    def set_codTercs(self, codTercs): self.codTercs = codTercs
    def get_codTercsSusp(self): return self.codTercsSusp
    def set_codTercsSusp(self, codTercsSusp): self.codTercsSusp = codTercsSusp
    def get_infoTercSusp(self): return self.infoTercSusp
    def set_infoTercSusp(self, infoTercSusp): self.infoTercSusp = infoTercSusp
    def add_infoTercSusp(self, value): self.infoTercSusp.append(value)
    def insert_infoTercSusp_at(self, index, value): self.infoTercSusp.insert(index, value)
    def replace_infoTercSusp_at(self, index, value): self.infoTercSusp[index] = value
    def get_infoEmprParcial(self): return self.infoEmprParcial
    def set_infoEmprParcial(self, infoEmprParcial): self.infoEmprParcial = infoEmprParcial
    def get_dadosOpPort(self): return self.dadosOpPort
    def set_dadosOpPort(self, dadosOpPort): self.dadosOpPort = dadosOpPort
    def get_basesRemun(self): return self.basesRemun
    def set_basesRemun(self, basesRemun): self.basesRemun = basesRemun
    def add_basesRemun(self, value): self.basesRemun.append(value)
    def insert_basesRemun_at(self, index, value): self.basesRemun.insert(index, value)
    def replace_basesRemun_at(self, index, value): self.basesRemun[index] = value
    def get_basesAvNPort(self): return self.basesAvNPort
    def set_basesAvNPort(self, basesAvNPort): self.basesAvNPort = basesAvNPort
    def get_infoSubstPatrOpPort(self): return self.infoSubstPatrOpPort
    def set_infoSubstPatrOpPort(self, infoSubstPatrOpPort): self.infoSubstPatrOpPort = infoSubstPatrOpPort
    def add_infoSubstPatrOpPort(self, value): self.infoSubstPatrOpPort.append(value)
    def insert_infoSubstPatrOpPort_at(self, index, value): self.infoSubstPatrOpPort.insert(index, value)
    def replace_infoSubstPatrOpPort_at(self, index, value): self.infoSubstPatrOpPort[index] = value
    def validate_codLotacaoType(self, value):
        # Validate type codLotacaoType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 30:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on codLotacaoType' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on codLotacaoType' % {"value" : value.encode("utf-8")} )
    def validate_fpasType(self, value):
        # Validate type fpasType, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_codTercsType(self, value):
        # Validate type codTercsType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) != 4:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on codTercsType' % {"value" : value.encode("utf-8")} )
    def validate_codTercsSuspType(self, value):
        # Validate type codTercsSuspType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) != 4:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on codTercsSuspType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.codLotacao is not None or
            self.fpas is not None or
            self.codTercs is not None or
            self.codTercsSusp is not None or
            self.infoTercSusp or
            self.infoEmprParcial is not None or
            self.dadosOpPort is not None or
            self.basesRemun or
            self.basesAvNPort is not None or
            self.infoSubstPatrOpPort
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='ideLotacaoType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ideLotacaoType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ideLotacaoType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='ideLotacaoType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ideLotacaoType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='ideLotacaoType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.codLotacao is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<codLotacao>%s</codLotacao>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.codLotacao), input_name='codLotacao')), eol_))
        if self.fpas is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<fpas>%s</fpas>%s' % (self.gds_format_integer(self.fpas, input_name='fpas'), eol_))
        if self.codTercs is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<codTercs>%s</codTercs>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.codTercs), input_name='codTercs')), eol_))
        if self.codTercsSusp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<codTercsSusp>%s</codTercsSusp>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.codTercsSusp), input_name='codTercsSusp')), eol_))
        for infoTercSusp_ in self.infoTercSusp:
            infoTercSusp_.export(outfile, level, namespaceprefix_, name_='infoTercSusp', pretty_print=pretty_print)
        if self.infoEmprParcial is not None:
            self.infoEmprParcial.export(outfile, level, namespaceprefix_, name_='infoEmprParcial', pretty_print=pretty_print)
        if self.dadosOpPort is not None:
            self.dadosOpPort.export(outfile, level, namespaceprefix_, name_='dadosOpPort', pretty_print=pretty_print)
        for basesRemun_ in self.basesRemun:
            basesRemun_.export(outfile, level, namespaceprefix_, name_='basesRemun', pretty_print=pretty_print)
        if self.basesAvNPort is not None:
            self.basesAvNPort.export(outfile, level, namespaceprefix_, name_='basesAvNPort', pretty_print=pretty_print)
        for infoSubstPatrOpPort_ in self.infoSubstPatrOpPort:
            infoSubstPatrOpPort_.export(outfile, level, namespaceprefix_, name_='infoSubstPatrOpPort', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'codLotacao':
            codLotacao_ = child_.text
            codLotacao_ = self.gds_validate_string(codLotacao_, node, 'codLotacao')
            self.codLotacao = codLotacao_
            # validate type codLotacaoType
            self.validate_codLotacaoType(self.codLotacao)
        elif nodeName_ == 'fpas' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'fpas')
            self.fpas = ival_
            # validate type fpasType
            self.validate_fpasType(self.fpas)
        elif nodeName_ == 'codTercs':
            codTercs_ = child_.text
            codTercs_ = self.gds_validate_string(codTercs_, node, 'codTercs')
            self.codTercs = codTercs_
            # validate type codTercsType
            self.validate_codTercsType(self.codTercs)
        elif nodeName_ == 'codTercsSusp':
            codTercsSusp_ = child_.text
            codTercsSusp_ = self.gds_validate_string(codTercsSusp_, node, 'codTercsSusp')
            self.codTercsSusp = codTercsSusp_
            # validate type codTercsSuspType
            self.validate_codTercsSuspType(self.codTercsSusp)
        elif nodeName_ == 'infoTercSusp':
            obj_ = infoTercSuspType.factory()
            obj_.build(child_)
            self.infoTercSusp.append(obj_)
            obj_.original_tagname_ = 'infoTercSusp'
        elif nodeName_ == 'infoEmprParcial':
            obj_ = infoEmprParcialType.factory()
            obj_.build(child_)
            self.infoEmprParcial = obj_
            obj_.original_tagname_ = 'infoEmprParcial'
        elif nodeName_ == 'dadosOpPort':
            obj_ = dadosOpPortType.factory()
            obj_.build(child_)
            self.dadosOpPort = obj_
            obj_.original_tagname_ = 'dadosOpPort'
        elif nodeName_ == 'basesRemun':
            obj_ = basesRemunType.factory()
            obj_.build(child_)
            self.basesRemun.append(obj_)
            obj_.original_tagname_ = 'basesRemun'
        elif nodeName_ == 'basesAvNPort':
            obj_ = basesAvNPortType.factory()
            obj_.build(child_)
            self.basesAvNPort = obj_
            obj_.original_tagname_ = 'basesAvNPort'
        elif nodeName_ == 'infoSubstPatrOpPort':
            obj_ = infoSubstPatrOpPortType.factory()
            obj_.build(child_)
            self.infoSubstPatrOpPort.append(obj_)
            obj_.original_tagname_ = 'infoSubstPatrOpPort'
# end class ideLotacaoType


class infoTercSuspType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, codTerc=None):
        self.original_tagname_ = None
        self.codTerc = codTerc
        self.validate_codTercType(self.codTerc)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infoTercSuspType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infoTercSuspType.subclass:
            return infoTercSuspType.subclass(*args_, **kwargs_)
        else:
            return infoTercSuspType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_codTerc(self): return self.codTerc
    def set_codTerc(self, codTerc): self.codTerc = codTerc
    def validate_codTercType(self, value):
        # Validate type codTercType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) != 4:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on codTercType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.codTerc is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='infoTercSuspType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infoTercSuspType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='infoTercSuspType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='infoTercSuspType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='infoTercSuspType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='infoTercSuspType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.codTerc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<codTerc>%s</codTerc>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.codTerc), input_name='codTerc')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'codTerc':
            codTerc_ = child_.text
            codTerc_ = self.gds_validate_string(codTerc_, node, 'codTerc')
            self.codTerc = codTerc_
            # validate type codTercType
            self.validate_codTercType(self.codTerc)
# end class infoTercSuspType


class infoEmprParcialType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, tpInscContrat=None, nrInscContrat=None, tpInscProp=None, nrInscProp=None):
        self.original_tagname_ = None
        self.tpInscContrat = tpInscContrat
        self.validate_tpInscContratType(self.tpInscContrat)
        self.nrInscContrat = nrInscContrat
        self.validate_nrInscContratType(self.nrInscContrat)
        self.tpInscProp = tpInscProp
        self.validate_tpInscPropType(self.tpInscProp)
        self.nrInscProp = nrInscProp
        self.validate_nrInscPropType(self.nrInscProp)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infoEmprParcialType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infoEmprParcialType.subclass:
            return infoEmprParcialType.subclass(*args_, **kwargs_)
        else:
            return infoEmprParcialType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tpInscContrat(self): return self.tpInscContrat
    def set_tpInscContrat(self, tpInscContrat): self.tpInscContrat = tpInscContrat
    def get_nrInscContrat(self): return self.nrInscContrat
    def set_nrInscContrat(self, nrInscContrat): self.nrInscContrat = nrInscContrat
    def get_tpInscProp(self): return self.tpInscProp
    def set_tpInscProp(self, tpInscProp): self.tpInscProp = tpInscProp
    def get_nrInscProp(self): return self.nrInscProp
    def set_nrInscProp(self, nrInscProp): self.nrInscProp = nrInscProp
    def validate_tpInscContratType(self, value):
        # Validate type tpInscContratType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_tpInscContratType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_tpInscContratType_patterns_, ))
    validate_tpInscContratType_patterns_ = [['^\\d$']]
    def validate_nrInscContratType(self, value):
        # Validate type nrInscContratType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_nrInscContratType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_nrInscContratType_patterns_, ))
    validate_nrInscContratType_patterns_ = [['^\\d{11,15}$']]
    def validate_tpInscPropType(self, value):
        # Validate type tpInscPropType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_tpInscPropType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_tpInscPropType_patterns_, ))
    validate_tpInscPropType_patterns_ = [['^\\d$']]
    def validate_nrInscPropType(self, value):
        # Validate type nrInscPropType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_nrInscPropType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_nrInscPropType_patterns_, ))
    validate_nrInscPropType_patterns_ = [['^\\d{11,15}$']]
    def hasContent_(self):
        if (
            self.tpInscContrat is not None or
            self.nrInscContrat is not None or
            self.tpInscProp is not None or
            self.nrInscProp is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='infoEmprParcialType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infoEmprParcialType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='infoEmprParcialType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='infoEmprParcialType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='infoEmprParcialType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='infoEmprParcialType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tpInscContrat is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tpInscContrat>%s</tpInscContrat>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.tpInscContrat), input_name='tpInscContrat')), eol_))
        if self.nrInscContrat is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<nrInscContrat>%s</nrInscContrat>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.nrInscContrat), input_name='nrInscContrat')), eol_))
        if self.tpInscProp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tpInscProp>%s</tpInscProp>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.tpInscProp), input_name='tpInscProp')), eol_))
        if self.nrInscProp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<nrInscProp>%s</nrInscProp>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.nrInscProp), input_name='nrInscProp')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tpInscContrat':
            tpInscContrat_ = child_.text
            tpInscContrat_ = self.gds_validate_string(tpInscContrat_, node, 'tpInscContrat')
            self.tpInscContrat = tpInscContrat_
            # validate type tpInscContratType
            self.validate_tpInscContratType(self.tpInscContrat)
        elif nodeName_ == 'nrInscContrat':
            nrInscContrat_ = child_.text
            nrInscContrat_ = self.gds_validate_string(nrInscContrat_, node, 'nrInscContrat')
            self.nrInscContrat = nrInscContrat_
            # validate type nrInscContratType
            self.validate_nrInscContratType(self.nrInscContrat)
        elif nodeName_ == 'tpInscProp':
            tpInscProp_ = child_.text
            tpInscProp_ = self.gds_validate_string(tpInscProp_, node, 'tpInscProp')
            self.tpInscProp = tpInscProp_
            # validate type tpInscPropType
            self.validate_tpInscPropType(self.tpInscProp)
        elif nodeName_ == 'nrInscProp':
            nrInscProp_ = child_.text
            nrInscProp_ = self.gds_validate_string(nrInscProp_, node, 'nrInscProp')
            self.nrInscProp = nrInscProp_
            # validate type nrInscPropType
            self.validate_nrInscPropType(self.nrInscProp)
# end class infoEmprParcialType


class dadosOpPortType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, cnpjOpPortuario=None, aliqRat=None, fap=None, aliqRatAjust=None):
        self.original_tagname_ = None
        self.cnpjOpPortuario = cnpjOpPortuario
        self.validate_cnpjOpPortuarioType(self.cnpjOpPortuario)
        self.aliqRat = aliqRat
        self.validate_aliqRatType1(self.aliqRat)
        self.fap = fap
        self.validate_fapType2(self.fap)
        self.aliqRatAjust = aliqRatAjust
        self.validate_aliqRatAjustType3(self.aliqRatAjust)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, dadosOpPortType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if dadosOpPortType.subclass:
            return dadosOpPortType.subclass(*args_, **kwargs_)
        else:
            return dadosOpPortType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cnpjOpPortuario(self): return self.cnpjOpPortuario
    def set_cnpjOpPortuario(self, cnpjOpPortuario): self.cnpjOpPortuario = cnpjOpPortuario
    def get_aliqRat(self): return self.aliqRat
    def set_aliqRat(self, aliqRat): self.aliqRat = aliqRat
    def get_fap(self): return self.fap
    def set_fap(self, fap): self.fap = fap
    def get_aliqRatAjust(self): return self.aliqRatAjust
    def set_aliqRatAjust(self, aliqRatAjust): self.aliqRatAjust = aliqRatAjust
    def validate_cnpjOpPortuarioType(self, value):
        # Validate type cnpjOpPortuarioType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) != 14:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on cnpjOpPortuarioType' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cnpjOpPortuarioType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cnpjOpPortuarioType_patterns_, ))
    validate_cnpjOpPortuarioType_patterns_ = [['^\\d{8,14}$']]
    def validate_aliqRatType1(self, value):
        # Validate type aliqRatType1, a restriction on xs:nonNegativeInteger.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_fapType2(self, value):
        # Validate type fapType2, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if value < 0.0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on fapType2' % {"value" : value} )
            if len(str(value)) >= 5:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on fapType2' % {"value" : value} )
    def validate_aliqRatAjustType3(self, value):
        # Validate type aliqRatAjustType3, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on aliqRatAjustType3' % {"value" : value} )
            if len(str(value)) >= 5:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on aliqRatAjustType3' % {"value" : value} )
    def hasContent_(self):
        if (
            self.cnpjOpPortuario is not None or
            self.aliqRat is not None or
            self.fap is not None or
            self.aliqRatAjust is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='dadosOpPortType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('dadosOpPortType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='dadosOpPortType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='dadosOpPortType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='dadosOpPortType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='dadosOpPortType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.cnpjOpPortuario is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<cnpjOpPortuario>%s</cnpjOpPortuario>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.cnpjOpPortuario), input_name='cnpjOpPortuario')), eol_))
        if self.aliqRat is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<aliqRat>%s</aliqRat>%s' % (self.gds_format_integer(self.aliqRat, input_name='aliqRat'), eol_))
        if self.fap is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<fap>%s</fap>%s' % (self.gds_format_float(self.fap, input_name='fap'), eol_))
        if self.aliqRatAjust is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<aliqRatAjust>%s</aliqRatAjust>%s' % (self.gds_format_float(self.aliqRatAjust, input_name='aliqRatAjust'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cnpjOpPortuario':
            cnpjOpPortuario_ = child_.text
            cnpjOpPortuario_ = self.gds_validate_string(cnpjOpPortuario_, node, 'cnpjOpPortuario')
            self.cnpjOpPortuario = cnpjOpPortuario_
            # validate type cnpjOpPortuarioType
            self.validate_cnpjOpPortuarioType(self.cnpjOpPortuario)
        elif nodeName_ == 'aliqRat' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'aliqRat')
            self.aliqRat = ival_
            # validate type aliqRatType1
            self.validate_aliqRatType1(self.aliqRat)
        elif nodeName_ == 'fap' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'fap')
            self.fap = fval_
            # validate type fapType2
            self.validate_fapType2(self.fap)
        elif nodeName_ == 'aliqRatAjust' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'aliqRatAjust')
            self.aliqRatAjust = fval_
            # validate type aliqRatAjustType3
            self.validate_aliqRatAjustType3(self.aliqRatAjust)
# end class dadosOpPortType


class basesRemunType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, indIncid=None, codCateg=None, basesCp=None):
        self.original_tagname_ = None
        self.indIncid = indIncid
        self.validate_indIncidType(self.indIncid)
        self.codCateg = codCateg
        self.validate_codCategType(self.codCateg)
        self.basesCp = basesCp
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, basesRemunType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if basesRemunType.subclass:
            return basesRemunType.subclass(*args_, **kwargs_)
        else:
            return basesRemunType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_indIncid(self): return self.indIncid
    def set_indIncid(self, indIncid): self.indIncid = indIncid
    def get_codCateg(self): return self.codCateg
    def set_codCateg(self, codCateg): self.codCateg = codCateg
    def get_basesCp(self): return self.basesCp
    def set_basesCp(self, basesCp): self.basesCp = basesCp
    def validate_indIncidType(self, value):
        # Validate type indIncidType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_indIncidType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_indIncidType_patterns_, ))
    validate_indIncidType_patterns_ = [['^\\d$']]
    def validate_codCategType(self, value):
        # Validate type codCategType, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_codCategType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_codCategType_patterns_, ))
    validate_codCategType_patterns_ = [['^\\d{3}$']]
    def hasContent_(self):
        if (
            self.indIncid is not None or
            self.codCateg is not None or
            self.basesCp is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='basesRemunType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('basesRemunType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='basesRemunType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='basesRemunType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='basesRemunType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='basesRemunType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.indIncid is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<indIncid>%s</indIncid>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.indIncid), input_name='indIncid')), eol_))
        if self.codCateg is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<codCateg>%s</codCateg>%s' % (self.gds_format_integer(self.codCateg, input_name='codCateg'), eol_))
        if self.basesCp is not None:
            self.basesCp.export(outfile, level, namespaceprefix_, name_='basesCp', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'indIncid':
            indIncid_ = child_.text
            indIncid_ = self.gds_validate_string(indIncid_, node, 'indIncid')
            self.indIncid = indIncid_
            # validate type indIncidType
            self.validate_indIncidType(self.indIncid)
        elif nodeName_ == 'codCateg' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'codCateg')
            self.codCateg = ival_
            # validate type codCategType
            self.validate_codCategType(self.codCateg)
        elif nodeName_ == 'basesCp':
            obj_ = basesCpType.factory()
            obj_.build(child_)
            self.basesCp = obj_
            obj_.original_tagname_ = 'basesCp'
# end class basesRemunType


class basesCpType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, vrBcCp00=None, vrBcCp15=None, vrBcCp20=None, vrBcCp25=None, vrSuspBcCp00=None, vrSuspBcCp15=None, vrSuspBcCp20=None, vrSuspBcCp25=None, vrDescSest=None, vrCalcSest=None, vrDescSenat=None, vrCalcSenat=None, vrSalFam=None, vrSalMat=None):
        self.original_tagname_ = None
        self.vrBcCp00 = vrBcCp00
        self.validate_vrBcCp00Type(self.vrBcCp00)
        self.vrBcCp15 = vrBcCp15
        self.validate_vrBcCp15Type(self.vrBcCp15)
        self.vrBcCp20 = vrBcCp20
        self.validate_vrBcCp20Type(self.vrBcCp20)
        self.vrBcCp25 = vrBcCp25
        self.validate_vrBcCp25Type(self.vrBcCp25)
        self.vrSuspBcCp00 = vrSuspBcCp00
        self.validate_vrSuspBcCp00Type(self.vrSuspBcCp00)
        self.vrSuspBcCp15 = vrSuspBcCp15
        self.validate_vrSuspBcCp15Type(self.vrSuspBcCp15)
        self.vrSuspBcCp20 = vrSuspBcCp20
        self.validate_vrSuspBcCp20Type(self.vrSuspBcCp20)
        self.vrSuspBcCp25 = vrSuspBcCp25
        self.validate_vrSuspBcCp25Type(self.vrSuspBcCp25)
        self.vrDescSest = vrDescSest
        self.validate_vrDescSestType(self.vrDescSest)
        self.vrCalcSest = vrCalcSest
        self.validate_vrCalcSestType(self.vrCalcSest)
        self.vrDescSenat = vrDescSenat
        self.validate_vrDescSenatType(self.vrDescSenat)
        self.vrCalcSenat = vrCalcSenat
        self.validate_vrCalcSenatType(self.vrCalcSenat)
        self.vrSalFam = vrSalFam
        self.validate_vrSalFamType(self.vrSalFam)
        self.vrSalMat = vrSalMat
        self.validate_vrSalMatType(self.vrSalMat)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, basesCpType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if basesCpType.subclass:
            return basesCpType.subclass(*args_, **kwargs_)
        else:
            return basesCpType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vrBcCp00(self): return self.vrBcCp00
    def set_vrBcCp00(self, vrBcCp00): self.vrBcCp00 = vrBcCp00
    def get_vrBcCp15(self): return self.vrBcCp15
    def set_vrBcCp15(self, vrBcCp15): self.vrBcCp15 = vrBcCp15
    def get_vrBcCp20(self): return self.vrBcCp20
    def set_vrBcCp20(self, vrBcCp20): self.vrBcCp20 = vrBcCp20
    def get_vrBcCp25(self): return self.vrBcCp25
    def set_vrBcCp25(self, vrBcCp25): self.vrBcCp25 = vrBcCp25
    def get_vrSuspBcCp00(self): return self.vrSuspBcCp00
    def set_vrSuspBcCp00(self, vrSuspBcCp00): self.vrSuspBcCp00 = vrSuspBcCp00
    def get_vrSuspBcCp15(self): return self.vrSuspBcCp15
    def set_vrSuspBcCp15(self, vrSuspBcCp15): self.vrSuspBcCp15 = vrSuspBcCp15
    def get_vrSuspBcCp20(self): return self.vrSuspBcCp20
    def set_vrSuspBcCp20(self, vrSuspBcCp20): self.vrSuspBcCp20 = vrSuspBcCp20
    def get_vrSuspBcCp25(self): return self.vrSuspBcCp25
    def set_vrSuspBcCp25(self, vrSuspBcCp25): self.vrSuspBcCp25 = vrSuspBcCp25
    def get_vrDescSest(self): return self.vrDescSest
    def set_vrDescSest(self, vrDescSest): self.vrDescSest = vrDescSest
    def get_vrCalcSest(self): return self.vrCalcSest
    def set_vrCalcSest(self, vrCalcSest): self.vrCalcSest = vrCalcSest
    def get_vrDescSenat(self): return self.vrDescSenat
    def set_vrDescSenat(self, vrDescSenat): self.vrDescSenat = vrDescSenat
    def get_vrCalcSenat(self): return self.vrCalcSenat
    def set_vrCalcSenat(self, vrCalcSenat): self.vrCalcSenat = vrCalcSenat
    def get_vrSalFam(self): return self.vrSalFam
    def set_vrSalFam(self, vrSalFam): self.vrSalFam = vrSalFam
    def get_vrSalMat(self): return self.vrSalMat
    def set_vrSalMat(self, vrSalMat): self.vrSalMat = vrSalMat
    def validate_vrBcCp00Type(self, value):
        # Validate type vrBcCp00Type, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 14:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on vrBcCp00Type' % {"value" : value} )
    def validate_vrBcCp15Type(self, value):
        # Validate type vrBcCp15Type, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 14:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on vrBcCp15Type' % {"value" : value} )
    def validate_vrBcCp20Type(self, value):
        # Validate type vrBcCp20Type, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 14:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on vrBcCp20Type' % {"value" : value} )
    def validate_vrBcCp25Type(self, value):
        # Validate type vrBcCp25Type, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 14:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on vrBcCp25Type' % {"value" : value} )
    def validate_vrSuspBcCp00Type(self, value):
        # Validate type vrSuspBcCp00Type, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 14:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on vrSuspBcCp00Type' % {"value" : value} )
    def validate_vrSuspBcCp15Type(self, value):
        # Validate type vrSuspBcCp15Type, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 14:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on vrSuspBcCp15Type' % {"value" : value} )
    def validate_vrSuspBcCp20Type(self, value):
        # Validate type vrSuspBcCp20Type, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 14:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on vrSuspBcCp20Type' % {"value" : value} )
    def validate_vrSuspBcCp25Type(self, value):
        # Validate type vrSuspBcCp25Type, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 14:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on vrSuspBcCp25Type' % {"value" : value} )
    def validate_vrDescSestType(self, value):
        # Validate type vrDescSestType, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 14:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on vrDescSestType' % {"value" : value} )
    def validate_vrCalcSestType(self, value):
        # Validate type vrCalcSestType, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 14:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on vrCalcSestType' % {"value" : value} )
    def validate_vrDescSenatType(self, value):
        # Validate type vrDescSenatType, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 14:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on vrDescSenatType' % {"value" : value} )
    def validate_vrCalcSenatType(self, value):
        # Validate type vrCalcSenatType, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 14:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on vrCalcSenatType' % {"value" : value} )
    def validate_vrSalFamType(self, value):
        # Validate type vrSalFamType, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 14:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on vrSalFamType' % {"value" : value} )
    def validate_vrSalMatType(self, value):
        # Validate type vrSalMatType, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 14:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on vrSalMatType' % {"value" : value} )
    def hasContent_(self):
        if (
            self.vrBcCp00 is not None or
            self.vrBcCp15 is not None or
            self.vrBcCp20 is not None or
            self.vrBcCp25 is not None or
            self.vrSuspBcCp00 is not None or
            self.vrSuspBcCp15 is not None or
            self.vrSuspBcCp20 is not None or
            self.vrSuspBcCp25 is not None or
            self.vrDescSest is not None or
            self.vrCalcSest is not None or
            self.vrDescSenat is not None or
            self.vrCalcSenat is not None or
            self.vrSalFam is not None or
            self.vrSalMat is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='basesCpType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('basesCpType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='basesCpType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='basesCpType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='basesCpType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='basesCpType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.vrBcCp00 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vrBcCp00>%s</vrBcCp00>%s' % (self.gds_format_float(self.vrBcCp00, input_name='vrBcCp00'), eol_))
        if self.vrBcCp15 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vrBcCp15>%s</vrBcCp15>%s' % (self.gds_format_float(self.vrBcCp15, input_name='vrBcCp15'), eol_))
        if self.vrBcCp20 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vrBcCp20>%s</vrBcCp20>%s' % (self.gds_format_float(self.vrBcCp20, input_name='vrBcCp20'), eol_))
        if self.vrBcCp25 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vrBcCp25>%s</vrBcCp25>%s' % (self.gds_format_float(self.vrBcCp25, input_name='vrBcCp25'), eol_))
        if self.vrSuspBcCp00 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vrSuspBcCp00>%s</vrSuspBcCp00>%s' % (self.gds_format_float(self.vrSuspBcCp00, input_name='vrSuspBcCp00'), eol_))
        if self.vrSuspBcCp15 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vrSuspBcCp15>%s</vrSuspBcCp15>%s' % (self.gds_format_float(self.vrSuspBcCp15, input_name='vrSuspBcCp15'), eol_))
        if self.vrSuspBcCp20 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vrSuspBcCp20>%s</vrSuspBcCp20>%s' % (self.gds_format_float(self.vrSuspBcCp20, input_name='vrSuspBcCp20'), eol_))
        if self.vrSuspBcCp25 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vrSuspBcCp25>%s</vrSuspBcCp25>%s' % (self.gds_format_float(self.vrSuspBcCp25, input_name='vrSuspBcCp25'), eol_))
        if self.vrDescSest is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vrDescSest>%s</vrDescSest>%s' % (self.gds_format_float(self.vrDescSest, input_name='vrDescSest'), eol_))
        if self.vrCalcSest is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vrCalcSest>%s</vrCalcSest>%s' % (self.gds_format_float(self.vrCalcSest, input_name='vrCalcSest'), eol_))
        if self.vrDescSenat is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vrDescSenat>%s</vrDescSenat>%s' % (self.gds_format_float(self.vrDescSenat, input_name='vrDescSenat'), eol_))
        if self.vrCalcSenat is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vrCalcSenat>%s</vrCalcSenat>%s' % (self.gds_format_float(self.vrCalcSenat, input_name='vrCalcSenat'), eol_))
        if self.vrSalFam is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vrSalFam>%s</vrSalFam>%s' % (self.gds_format_float(self.vrSalFam, input_name='vrSalFam'), eol_))
        if self.vrSalMat is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vrSalMat>%s</vrSalMat>%s' % (self.gds_format_float(self.vrSalMat, input_name='vrSalMat'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'vrBcCp00' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'vrBcCp00')
            self.vrBcCp00 = fval_
            # validate type vrBcCp00Type
            self.validate_vrBcCp00Type(self.vrBcCp00)
        elif nodeName_ == 'vrBcCp15' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'vrBcCp15')
            self.vrBcCp15 = fval_
            # validate type vrBcCp15Type
            self.validate_vrBcCp15Type(self.vrBcCp15)
        elif nodeName_ == 'vrBcCp20' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'vrBcCp20')
            self.vrBcCp20 = fval_
            # validate type vrBcCp20Type
            self.validate_vrBcCp20Type(self.vrBcCp20)
        elif nodeName_ == 'vrBcCp25' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'vrBcCp25')
            self.vrBcCp25 = fval_
            # validate type vrBcCp25Type
            self.validate_vrBcCp25Type(self.vrBcCp25)
        elif nodeName_ == 'vrSuspBcCp00' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'vrSuspBcCp00')
            self.vrSuspBcCp00 = fval_
            # validate type vrSuspBcCp00Type
            self.validate_vrSuspBcCp00Type(self.vrSuspBcCp00)
        elif nodeName_ == 'vrSuspBcCp15' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'vrSuspBcCp15')
            self.vrSuspBcCp15 = fval_
            # validate type vrSuspBcCp15Type
            self.validate_vrSuspBcCp15Type(self.vrSuspBcCp15)
        elif nodeName_ == 'vrSuspBcCp20' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'vrSuspBcCp20')
            self.vrSuspBcCp20 = fval_
            # validate type vrSuspBcCp20Type
            self.validate_vrSuspBcCp20Type(self.vrSuspBcCp20)
        elif nodeName_ == 'vrSuspBcCp25' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'vrSuspBcCp25')
            self.vrSuspBcCp25 = fval_
            # validate type vrSuspBcCp25Type
            self.validate_vrSuspBcCp25Type(self.vrSuspBcCp25)
        elif nodeName_ == 'vrDescSest' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'vrDescSest')
            self.vrDescSest = fval_
            # validate type vrDescSestType
            self.validate_vrDescSestType(self.vrDescSest)
        elif nodeName_ == 'vrCalcSest' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'vrCalcSest')
            self.vrCalcSest = fval_
            # validate type vrCalcSestType
            self.validate_vrCalcSestType(self.vrCalcSest)
        elif nodeName_ == 'vrDescSenat' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'vrDescSenat')
            self.vrDescSenat = fval_
            # validate type vrDescSenatType
            self.validate_vrDescSenatType(self.vrDescSenat)
        elif nodeName_ == 'vrCalcSenat' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'vrCalcSenat')
            self.vrCalcSenat = fval_
            # validate type vrCalcSenatType
            self.validate_vrCalcSenatType(self.vrCalcSenat)
        elif nodeName_ == 'vrSalFam' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'vrSalFam')
            self.vrSalFam = fval_
            # validate type vrSalFamType
            self.validate_vrSalFamType(self.vrSalFam)
        elif nodeName_ == 'vrSalMat' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'vrSalMat')
            self.vrSalMat = fval_
            # validate type vrSalMatType
            self.validate_vrSalMatType(self.vrSalMat)
# end class basesCpType


class basesAvNPortType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, vrBcCp00=None, vrBcCp15=None, vrBcCp20=None, vrBcCp25=None, vrBcCp13=None, vrBcFgts=None, vrDescCP=None):
        self.original_tagname_ = None
        self.vrBcCp00 = vrBcCp00
        self.validate_vrBcCp00Type4(self.vrBcCp00)
        self.vrBcCp15 = vrBcCp15
        self.validate_vrBcCp15Type5(self.vrBcCp15)
        self.vrBcCp20 = vrBcCp20
        self.validate_vrBcCp20Type6(self.vrBcCp20)
        self.vrBcCp25 = vrBcCp25
        self.validate_vrBcCp25Type7(self.vrBcCp25)
        self.vrBcCp13 = vrBcCp13
        self.validate_vrBcCp13Type(self.vrBcCp13)
        self.vrBcFgts = vrBcFgts
        self.validate_vrBcFgtsType(self.vrBcFgts)
        self.vrDescCP = vrDescCP
        self.validate_vrDescCPType8(self.vrDescCP)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, basesAvNPortType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if basesAvNPortType.subclass:
            return basesAvNPortType.subclass(*args_, **kwargs_)
        else:
            return basesAvNPortType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vrBcCp00(self): return self.vrBcCp00
    def set_vrBcCp00(self, vrBcCp00): self.vrBcCp00 = vrBcCp00
    def get_vrBcCp15(self): return self.vrBcCp15
    def set_vrBcCp15(self, vrBcCp15): self.vrBcCp15 = vrBcCp15
    def get_vrBcCp20(self): return self.vrBcCp20
    def set_vrBcCp20(self, vrBcCp20): self.vrBcCp20 = vrBcCp20
    def get_vrBcCp25(self): return self.vrBcCp25
    def set_vrBcCp25(self, vrBcCp25): self.vrBcCp25 = vrBcCp25
    def get_vrBcCp13(self): return self.vrBcCp13
    def set_vrBcCp13(self, vrBcCp13): self.vrBcCp13 = vrBcCp13
    def get_vrBcFgts(self): return self.vrBcFgts
    def set_vrBcFgts(self, vrBcFgts): self.vrBcFgts = vrBcFgts
    def get_vrDescCP(self): return self.vrDescCP
    def set_vrDescCP(self, vrDescCP): self.vrDescCP = vrDescCP
    def validate_vrBcCp00Type4(self, value):
        # Validate type vrBcCp00Type4, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 14:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on vrBcCp00Type4' % {"value" : value} )
    def validate_vrBcCp15Type5(self, value):
        # Validate type vrBcCp15Type5, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 14:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on vrBcCp15Type5' % {"value" : value} )
    def validate_vrBcCp20Type6(self, value):
        # Validate type vrBcCp20Type6, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 14:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on vrBcCp20Type6' % {"value" : value} )
    def validate_vrBcCp25Type7(self, value):
        # Validate type vrBcCp25Type7, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 14:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on vrBcCp25Type7' % {"value" : value} )
    def validate_vrBcCp13Type(self, value):
        # Validate type vrBcCp13Type, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 14:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on vrBcCp13Type' % {"value" : value} )
    def validate_vrBcFgtsType(self, value):
        # Validate type vrBcFgtsType, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 14:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on vrBcFgtsType' % {"value" : value} )
    def validate_vrDescCPType8(self, value):
        # Validate type vrDescCPType8, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 14:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on vrDescCPType8' % {"value" : value} )
    def hasContent_(self):
        if (
            self.vrBcCp00 is not None or
            self.vrBcCp15 is not None or
            self.vrBcCp20 is not None or
            self.vrBcCp25 is not None or
            self.vrBcCp13 is not None or
            self.vrBcFgts is not None or
            self.vrDescCP is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='basesAvNPortType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('basesAvNPortType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='basesAvNPortType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='basesAvNPortType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='basesAvNPortType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='basesAvNPortType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.vrBcCp00 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vrBcCp00>%s</vrBcCp00>%s' % (self.gds_format_float(self.vrBcCp00, input_name='vrBcCp00'), eol_))
        if self.vrBcCp15 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vrBcCp15>%s</vrBcCp15>%s' % (self.gds_format_float(self.vrBcCp15, input_name='vrBcCp15'), eol_))
        if self.vrBcCp20 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vrBcCp20>%s</vrBcCp20>%s' % (self.gds_format_float(self.vrBcCp20, input_name='vrBcCp20'), eol_))
        if self.vrBcCp25 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vrBcCp25>%s</vrBcCp25>%s' % (self.gds_format_float(self.vrBcCp25, input_name='vrBcCp25'), eol_))
        if self.vrBcCp13 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vrBcCp13>%s</vrBcCp13>%s' % (self.gds_format_float(self.vrBcCp13, input_name='vrBcCp13'), eol_))
        if self.vrBcFgts is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vrBcFgts>%s</vrBcFgts>%s' % (self.gds_format_float(self.vrBcFgts, input_name='vrBcFgts'), eol_))
        if self.vrDescCP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vrDescCP>%s</vrDescCP>%s' % (self.gds_format_float(self.vrDescCP, input_name='vrDescCP'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'vrBcCp00' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'vrBcCp00')
            self.vrBcCp00 = fval_
            # validate type vrBcCp00Type4
            self.validate_vrBcCp00Type4(self.vrBcCp00)
        elif nodeName_ == 'vrBcCp15' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'vrBcCp15')
            self.vrBcCp15 = fval_
            # validate type vrBcCp15Type5
            self.validate_vrBcCp15Type5(self.vrBcCp15)
        elif nodeName_ == 'vrBcCp20' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'vrBcCp20')
            self.vrBcCp20 = fval_
            # validate type vrBcCp20Type6
            self.validate_vrBcCp20Type6(self.vrBcCp20)
        elif nodeName_ == 'vrBcCp25' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'vrBcCp25')
            self.vrBcCp25 = fval_
            # validate type vrBcCp25Type7
            self.validate_vrBcCp25Type7(self.vrBcCp25)
        elif nodeName_ == 'vrBcCp13' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'vrBcCp13')
            self.vrBcCp13 = fval_
            # validate type vrBcCp13Type
            self.validate_vrBcCp13Type(self.vrBcCp13)
        elif nodeName_ == 'vrBcFgts' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'vrBcFgts')
            self.vrBcFgts = fval_
            # validate type vrBcFgtsType
            self.validate_vrBcFgtsType(self.vrBcFgts)
        elif nodeName_ == 'vrDescCP' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'vrDescCP')
            self.vrDescCP = fval_
            # validate type vrDescCPType8
            self.validate_vrDescCPType8(self.vrDescCP)
# end class basesAvNPortType


class infoSubstPatrOpPortType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, cnpjOpPortuario=None):
        self.original_tagname_ = None
        self.cnpjOpPortuario = cnpjOpPortuario
        self.validate_cnpjOpPortuarioType9(self.cnpjOpPortuario)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infoSubstPatrOpPortType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infoSubstPatrOpPortType.subclass:
            return infoSubstPatrOpPortType.subclass(*args_, **kwargs_)
        else:
            return infoSubstPatrOpPortType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cnpjOpPortuario(self): return self.cnpjOpPortuario
    def set_cnpjOpPortuario(self, cnpjOpPortuario): self.cnpjOpPortuario = cnpjOpPortuario
    def validate_cnpjOpPortuarioType9(self, value):
        # Validate type cnpjOpPortuarioType9, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) != 14:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on cnpjOpPortuarioType9' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cnpjOpPortuarioType9_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cnpjOpPortuarioType9_patterns_, ))
    validate_cnpjOpPortuarioType9_patterns_ = [['^\\d{8,14}$']]
    def hasContent_(self):
        if (
            self.cnpjOpPortuario is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='infoSubstPatrOpPortType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infoSubstPatrOpPortType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='infoSubstPatrOpPortType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='infoSubstPatrOpPortType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='infoSubstPatrOpPortType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='infoSubstPatrOpPortType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.cnpjOpPortuario is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<cnpjOpPortuario>%s</cnpjOpPortuario>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.cnpjOpPortuario), input_name='cnpjOpPortuario')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cnpjOpPortuario':
            cnpjOpPortuario_ = child_.text
            cnpjOpPortuario_ = self.gds_validate_string(cnpjOpPortuario_, node, 'cnpjOpPortuario')
            self.cnpjOpPortuario = cnpjOpPortuario_
            # validate type cnpjOpPortuarioType9
            self.validate_cnpjOpPortuarioType9(self.cnpjOpPortuario)
# end class infoSubstPatrOpPortType


class basesAquisType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, indAquis=None, vlrAquis=None, vrCPDescPR=None, vrCPNRet=None, vrRatNRet=None, vrSenarNRet=None, vrCPCalcPR=None, vrRatDescPR=None, vrRatCalcPR=None, vrSenarDesc=None, vrSenarCalc=None):
        self.original_tagname_ = None
        self.indAquis = indAquis
        self.validate_indAquisType(self.indAquis)
        self.vlrAquis = vlrAquis
        self.validate_vlrAquisType(self.vlrAquis)
        self.vrCPDescPR = vrCPDescPR
        self.validate_vrCPDescPRType(self.vrCPDescPR)
        self.vrCPNRet = vrCPNRet
        self.validate_vrCPNRetType(self.vrCPNRet)
        self.vrRatNRet = vrRatNRet
        self.validate_vrRatNRetType(self.vrRatNRet)
        self.vrSenarNRet = vrSenarNRet
        self.validate_vrSenarNRetType(self.vrSenarNRet)
        self.vrCPCalcPR = vrCPCalcPR
        self.validate_vrCPCalcPRType(self.vrCPCalcPR)
        self.vrRatDescPR = vrRatDescPR
        self.validate_vrRatDescPRType(self.vrRatDescPR)
        self.vrRatCalcPR = vrRatCalcPR
        self.validate_vrRatCalcPRType(self.vrRatCalcPR)
        self.vrSenarDesc = vrSenarDesc
        self.validate_vrSenarDescType(self.vrSenarDesc)
        self.vrSenarCalc = vrSenarCalc
        self.validate_vrSenarCalcType(self.vrSenarCalc)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, basesAquisType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if basesAquisType.subclass:
            return basesAquisType.subclass(*args_, **kwargs_)
        else:
            return basesAquisType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_indAquis(self): return self.indAquis
    def set_indAquis(self, indAquis): self.indAquis = indAquis
    def get_vlrAquis(self): return self.vlrAquis
    def set_vlrAquis(self, vlrAquis): self.vlrAquis = vlrAquis
    def get_vrCPDescPR(self): return self.vrCPDescPR
    def set_vrCPDescPR(self, vrCPDescPR): self.vrCPDescPR = vrCPDescPR
    def get_vrCPNRet(self): return self.vrCPNRet
    def set_vrCPNRet(self, vrCPNRet): self.vrCPNRet = vrCPNRet
    def get_vrRatNRet(self): return self.vrRatNRet
    def set_vrRatNRet(self, vrRatNRet): self.vrRatNRet = vrRatNRet
    def get_vrSenarNRet(self): return self.vrSenarNRet
    def set_vrSenarNRet(self, vrSenarNRet): self.vrSenarNRet = vrSenarNRet
    def get_vrCPCalcPR(self): return self.vrCPCalcPR
    def set_vrCPCalcPR(self, vrCPCalcPR): self.vrCPCalcPR = vrCPCalcPR
    def get_vrRatDescPR(self): return self.vrRatDescPR
    def set_vrRatDescPR(self, vrRatDescPR): self.vrRatDescPR = vrRatDescPR
    def get_vrRatCalcPR(self): return self.vrRatCalcPR
    def set_vrRatCalcPR(self, vrRatCalcPR): self.vrRatCalcPR = vrRatCalcPR
    def get_vrSenarDesc(self): return self.vrSenarDesc
    def set_vrSenarDesc(self, vrSenarDesc): self.vrSenarDesc = vrSenarDesc
    def get_vrSenarCalc(self): return self.vrSenarCalc
    def set_vrSenarCalc(self, vrSenarCalc): self.vrSenarCalc = vrSenarCalc
    def validate_indAquisType(self, value):
        # Validate type indAquisType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_indAquisType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_indAquisType_patterns_, ))
    validate_indAquisType_patterns_ = [['^\\d$']]
    def validate_vlrAquisType(self, value):
        # Validate type vlrAquisType, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 14:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on vlrAquisType' % {"value" : value} )
    def validate_vrCPDescPRType(self, value):
        # Validate type vrCPDescPRType, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 14:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on vrCPDescPRType' % {"value" : value} )
    def validate_vrCPNRetType(self, value):
        # Validate type vrCPNRetType, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 14:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on vrCPNRetType' % {"value" : value} )
    def validate_vrRatNRetType(self, value):
        # Validate type vrRatNRetType, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 14:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on vrRatNRetType' % {"value" : value} )
    def validate_vrSenarNRetType(self, value):
        # Validate type vrSenarNRetType, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 14:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on vrSenarNRetType' % {"value" : value} )
    def validate_vrCPCalcPRType(self, value):
        # Validate type vrCPCalcPRType, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 14:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on vrCPCalcPRType' % {"value" : value} )
    def validate_vrRatDescPRType(self, value):
        # Validate type vrRatDescPRType, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 14:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on vrRatDescPRType' % {"value" : value} )
    def validate_vrRatCalcPRType(self, value):
        # Validate type vrRatCalcPRType, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 14:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on vrRatCalcPRType' % {"value" : value} )
    def validate_vrSenarDescType(self, value):
        # Validate type vrSenarDescType, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 14:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on vrSenarDescType' % {"value" : value} )
    def validate_vrSenarCalcType(self, value):
        # Validate type vrSenarCalcType, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 14:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on vrSenarCalcType' % {"value" : value} )
    def hasContent_(self):
        if (
            self.indAquis is not None or
            self.vlrAquis is not None or
            self.vrCPDescPR is not None or
            self.vrCPNRet is not None or
            self.vrRatNRet is not None or
            self.vrSenarNRet is not None or
            self.vrCPCalcPR is not None or
            self.vrRatDescPR is not None or
            self.vrRatCalcPR is not None or
            self.vrSenarDesc is not None or
            self.vrSenarCalc is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='basesAquisType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('basesAquisType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='basesAquisType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='basesAquisType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='basesAquisType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='basesAquisType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.indAquis is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<indAquis>%s</indAquis>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.indAquis), input_name='indAquis')), eol_))
        if self.vlrAquis is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vlrAquis>%s</vlrAquis>%s' % (self.gds_format_float(self.vlrAquis, input_name='vlrAquis'), eol_))
        if self.vrCPDescPR is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vrCPDescPR>%s</vrCPDescPR>%s' % (self.gds_format_float(self.vrCPDescPR, input_name='vrCPDescPR'), eol_))
        if self.vrCPNRet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vrCPNRet>%s</vrCPNRet>%s' % (self.gds_format_float(self.vrCPNRet, input_name='vrCPNRet'), eol_))
        if self.vrRatNRet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vrRatNRet>%s</vrRatNRet>%s' % (self.gds_format_float(self.vrRatNRet, input_name='vrRatNRet'), eol_))
        if self.vrSenarNRet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vrSenarNRet>%s</vrSenarNRet>%s' % (self.gds_format_float(self.vrSenarNRet, input_name='vrSenarNRet'), eol_))
        if self.vrCPCalcPR is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vrCPCalcPR>%s</vrCPCalcPR>%s' % (self.gds_format_float(self.vrCPCalcPR, input_name='vrCPCalcPR'), eol_))
        if self.vrRatDescPR is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vrRatDescPR>%s</vrRatDescPR>%s' % (self.gds_format_float(self.vrRatDescPR, input_name='vrRatDescPR'), eol_))
        if self.vrRatCalcPR is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vrRatCalcPR>%s</vrRatCalcPR>%s' % (self.gds_format_float(self.vrRatCalcPR, input_name='vrRatCalcPR'), eol_))
        if self.vrSenarDesc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vrSenarDesc>%s</vrSenarDesc>%s' % (self.gds_format_float(self.vrSenarDesc, input_name='vrSenarDesc'), eol_))
        if self.vrSenarCalc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vrSenarCalc>%s</vrSenarCalc>%s' % (self.gds_format_float(self.vrSenarCalc, input_name='vrSenarCalc'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'indAquis':
            indAquis_ = child_.text
            indAquis_ = self.gds_validate_string(indAquis_, node, 'indAquis')
            self.indAquis = indAquis_
            # validate type indAquisType
            self.validate_indAquisType(self.indAquis)
        elif nodeName_ == 'vlrAquis' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'vlrAquis')
            self.vlrAquis = fval_
            # validate type vlrAquisType
            self.validate_vlrAquisType(self.vlrAquis)
        elif nodeName_ == 'vrCPDescPR' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'vrCPDescPR')
            self.vrCPDescPR = fval_
            # validate type vrCPDescPRType
            self.validate_vrCPDescPRType(self.vrCPDescPR)
        elif nodeName_ == 'vrCPNRet' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'vrCPNRet')
            self.vrCPNRet = fval_
            # validate type vrCPNRetType
            self.validate_vrCPNRetType(self.vrCPNRet)
        elif nodeName_ == 'vrRatNRet' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'vrRatNRet')
            self.vrRatNRet = fval_
            # validate type vrRatNRetType
            self.validate_vrRatNRetType(self.vrRatNRet)
        elif nodeName_ == 'vrSenarNRet' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'vrSenarNRet')
            self.vrSenarNRet = fval_
            # validate type vrSenarNRetType
            self.validate_vrSenarNRetType(self.vrSenarNRet)
        elif nodeName_ == 'vrCPCalcPR' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'vrCPCalcPR')
            self.vrCPCalcPR = fval_
            # validate type vrCPCalcPRType
            self.validate_vrCPCalcPRType(self.vrCPCalcPR)
        elif nodeName_ == 'vrRatDescPR' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'vrRatDescPR')
            self.vrRatDescPR = fval_
            # validate type vrRatDescPRType
            self.validate_vrRatDescPRType(self.vrRatDescPR)
        elif nodeName_ == 'vrRatCalcPR' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'vrRatCalcPR')
            self.vrRatCalcPR = fval_
            # validate type vrRatCalcPRType
            self.validate_vrRatCalcPRType(self.vrRatCalcPR)
        elif nodeName_ == 'vrSenarDesc' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'vrSenarDesc')
            self.vrSenarDesc = fval_
            # validate type vrSenarDescType
            self.validate_vrSenarDescType(self.vrSenarDesc)
        elif nodeName_ == 'vrSenarCalc' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'vrSenarCalc')
            self.vrSenarCalc = fval_
            # validate type vrSenarCalcType
            self.validate_vrSenarCalcType(self.vrSenarCalc)
# end class basesAquisType


class basesComercType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, indComerc=None, vrBcComPR=None, vrCPSusp=None, vrRatSusp=None, vrSenarSusp=None):
        self.original_tagname_ = None
        self.indComerc = indComerc
        self.validate_indComercType(self.indComerc)
        self.vrBcComPR = vrBcComPR
        self.validate_vrBcComPRType(self.vrBcComPR)
        self.vrCPSusp = vrCPSusp
        self.validate_vrCPSuspType(self.vrCPSusp)
        self.vrRatSusp = vrRatSusp
        self.validate_vrRatSuspType(self.vrRatSusp)
        self.vrSenarSusp = vrSenarSusp
        self.validate_vrSenarSuspType(self.vrSenarSusp)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, basesComercType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if basesComercType.subclass:
            return basesComercType.subclass(*args_, **kwargs_)
        else:
            return basesComercType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_indComerc(self): return self.indComerc
    def set_indComerc(self, indComerc): self.indComerc = indComerc
    def get_vrBcComPR(self): return self.vrBcComPR
    def set_vrBcComPR(self, vrBcComPR): self.vrBcComPR = vrBcComPR
    def get_vrCPSusp(self): return self.vrCPSusp
    def set_vrCPSusp(self, vrCPSusp): self.vrCPSusp = vrCPSusp
    def get_vrRatSusp(self): return self.vrRatSusp
    def set_vrRatSusp(self, vrRatSusp): self.vrRatSusp = vrRatSusp
    def get_vrSenarSusp(self): return self.vrSenarSusp
    def set_vrSenarSusp(self, vrSenarSusp): self.vrSenarSusp = vrSenarSusp
    def validate_indComercType(self, value):
        # Validate type indComercType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_indComercType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_indComercType_patterns_, ))
    validate_indComercType_patterns_ = [['^\\d$']]
    def validate_vrBcComPRType(self, value):
        # Validate type vrBcComPRType, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 14:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on vrBcComPRType' % {"value" : value} )
    def validate_vrCPSuspType(self, value):
        # Validate type vrCPSuspType, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 14:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on vrCPSuspType' % {"value" : value} )
    def validate_vrRatSuspType(self, value):
        # Validate type vrRatSuspType, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 14:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on vrRatSuspType' % {"value" : value} )
    def validate_vrSenarSuspType(self, value):
        # Validate type vrSenarSuspType, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 14:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on vrSenarSuspType' % {"value" : value} )
    def hasContent_(self):
        if (
            self.indComerc is not None or
            self.vrBcComPR is not None or
            self.vrCPSusp is not None or
            self.vrRatSusp is not None or
            self.vrSenarSusp is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='basesComercType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('basesComercType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='basesComercType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='basesComercType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='basesComercType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='basesComercType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.indComerc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<indComerc>%s</indComerc>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.indComerc), input_name='indComerc')), eol_))
        if self.vrBcComPR is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vrBcComPR>%s</vrBcComPR>%s' % (self.gds_format_float(self.vrBcComPR, input_name='vrBcComPR'), eol_))
        if self.vrCPSusp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vrCPSusp>%s</vrCPSusp>%s' % (self.gds_format_float(self.vrCPSusp, input_name='vrCPSusp'), eol_))
        if self.vrRatSusp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vrRatSusp>%s</vrRatSusp>%s' % (self.gds_format_float(self.vrRatSusp, input_name='vrRatSusp'), eol_))
        if self.vrSenarSusp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vrSenarSusp>%s</vrSenarSusp>%s' % (self.gds_format_float(self.vrSenarSusp, input_name='vrSenarSusp'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'indComerc':
            indComerc_ = child_.text
            indComerc_ = self.gds_validate_string(indComerc_, node, 'indComerc')
            self.indComerc = indComerc_
            # validate type indComercType
            self.validate_indComercType(self.indComerc)
        elif nodeName_ == 'vrBcComPR' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'vrBcComPR')
            self.vrBcComPR = fval_
            # validate type vrBcComPRType
            self.validate_vrBcComPRType(self.vrBcComPR)
        elif nodeName_ == 'vrCPSusp' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'vrCPSusp')
            self.vrCPSusp = fval_
            # validate type vrCPSuspType
            self.validate_vrCPSuspType(self.vrCPSusp)
        elif nodeName_ == 'vrRatSusp' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'vrRatSusp')
            self.vrRatSusp = fval_
            # validate type vrRatSuspType
            self.validate_vrRatSuspType(self.vrRatSusp)
        elif nodeName_ == 'vrSenarSusp' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'vrSenarSusp')
            self.vrSenarSusp = fval_
            # validate type vrSenarSuspType
            self.validate_vrSenarSuspType(self.vrSenarSusp)
# end class basesComercType


class infoCREstabType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, tpCR=None, vrCR=None, vrSuspCR=None):
        self.original_tagname_ = None
        self.tpCR = tpCR
        self.validate_tpCRType(self.tpCR)
        self.vrCR = vrCR
        self.validate_vrCRType(self.vrCR)
        self.vrSuspCR = vrSuspCR
        self.validate_vrSuspCRType(self.vrSuspCR)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infoCREstabType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infoCREstabType.subclass:
            return infoCREstabType.subclass(*args_, **kwargs_)
        else:
            return infoCREstabType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tpCR(self): return self.tpCR
    def set_tpCR(self, tpCR): self.tpCR = tpCR
    def get_vrCR(self): return self.vrCR
    def set_vrCR(self, vrCR): self.vrCR = vrCR
    def get_vrSuspCR(self): return self.vrSuspCR
    def set_vrSuspCR(self, vrSuspCR): self.vrSuspCR = vrSuspCR
    def validate_tpCRType(self, value):
        # Validate type tpCRType, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_vrCRType(self, value):
        # Validate type vrCRType, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 14:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on vrCRType' % {"value" : value} )
    def validate_vrSuspCRType(self, value):
        # Validate type vrSuspCRType, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 14:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on vrSuspCRType' % {"value" : value} )
    def hasContent_(self):
        if (
            self.tpCR is not None or
            self.vrCR is not None or
            self.vrSuspCR is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='infoCREstabType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infoCREstabType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='infoCREstabType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='infoCREstabType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='infoCREstabType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='infoCREstabType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tpCR is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tpCR>%s</tpCR>%s' % (self.gds_format_integer(self.tpCR, input_name='tpCR'), eol_))
        if self.vrCR is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vrCR>%s</vrCR>%s' % (self.gds_format_float(self.vrCR, input_name='vrCR'), eol_))
        if self.vrSuspCR is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vrSuspCR>%s</vrSuspCR>%s' % (self.gds_format_float(self.vrSuspCR, input_name='vrSuspCR'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tpCR' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'tpCR')
            self.tpCR = ival_
            # validate type tpCRType
            self.validate_tpCRType(self.tpCR)
        elif nodeName_ == 'vrCR' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'vrCR')
            self.vrCR = fval_
            # validate type vrCRType
            self.validate_vrCRType(self.vrCR)
        elif nodeName_ == 'vrSuspCR' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'vrSuspCR')
            self.vrSuspCR = fval_
            # validate type vrSuspCRType
            self.validate_vrSuspCRType(self.vrSuspCR)
# end class infoCREstabType


class infoCRContribType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, tpCR=None, vrCR=None, vrCRSusp=None):
        self.original_tagname_ = None
        self.tpCR = tpCR
        self.validate_tpCRType10(self.tpCR)
        self.vrCR = vrCR
        self.validate_vrCRType11(self.vrCR)
        self.vrCRSusp = vrCRSusp
        self.validate_vrCRSuspType(self.vrCRSusp)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infoCRContribType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infoCRContribType.subclass:
            return infoCRContribType.subclass(*args_, **kwargs_)
        else:
            return infoCRContribType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tpCR(self): return self.tpCR
    def set_tpCR(self, tpCR): self.tpCR = tpCR
    def get_vrCR(self): return self.vrCR
    def set_vrCR(self, vrCR): self.vrCR = vrCR
    def get_vrCRSusp(self): return self.vrCRSusp
    def set_vrCRSusp(self, vrCRSusp): self.vrCRSusp = vrCRSusp
    def validate_tpCRType10(self, value):
        # Validate type tpCRType10, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_vrCRType11(self, value):
        # Validate type vrCRType11, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 14:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on vrCRType11' % {"value" : value} )
    def validate_vrCRSuspType(self, value):
        # Validate type vrCRSuspType, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 14:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on vrCRSuspType' % {"value" : value} )
    def hasContent_(self):
        if (
            self.tpCR is not None or
            self.vrCR is not None or
            self.vrCRSusp is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='infoCRContribType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infoCRContribType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='infoCRContribType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='infoCRContribType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='infoCRContribType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='infoCRContribType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tpCR is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tpCR>%s</tpCR>%s' % (self.gds_format_integer(self.tpCR, input_name='tpCR'), eol_))
        if self.vrCR is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vrCR>%s</vrCR>%s' % (self.gds_format_float(self.vrCR, input_name='vrCR'), eol_))
        if self.vrCRSusp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vrCRSusp>%s</vrCRSusp>%s' % (self.gds_format_float(self.vrCRSusp, input_name='vrCRSusp'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tpCR' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'tpCR')
            self.tpCR = ival_
            # validate type tpCRType10
            self.validate_tpCRType10(self.tpCR)
        elif nodeName_ == 'vrCR' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'vrCR')
            self.vrCR = fval_
            # validate type vrCRType11
            self.validate_vrCRType11(self.vrCR)
        elif nodeName_ == 'vrCRSusp' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'vrCRSusp')
            self.vrCRSusp = fval_
            # validate type vrCRSuspType
            self.validate_vrCRSuspType(self.vrCRSusp)
# end class infoCRContribType


GDSClassesMapping = {
    'CanonicalizationMethod': CanonicalizationMethodType,
    'DSAKeyValue': DSAKeyValueType,
    'DigestMethod': DigestMethodType,
    'KeyInfo': KeyInfoType,
    'KeyValue': KeyValueType,
    'Manifest': ManifestType,
    'Object': ObjectType,
    'PGPData': PGPDataType,
    'RSAKeyValue': RSAKeyValueType,
    'Reference': ReferenceType,
    'RetrievalMethod': RetrievalMethodType,
    'SPKIData': SPKIDataType,
    'Signature': SignatureType,
    'SignatureMethod': SignatureMethodType,
    'SignatureProperties': SignaturePropertiesType,
    'SignatureProperty': SignaturePropertyType,
    'SignatureValue': SignatureValueType,
    'SignedInfo': SignedInfoType,
    'Transform': TransformType,
    'Transforms': TransformsType,
    'X509Data': X509DataType,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'eSocial'
        rootClass = eSocial
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'eSocial'
        rootClass = eSocial
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    '''Parse a string, create the object tree, and export it.

    Arguments:
    - inString -- A string.  This XML fragment should not start
      with an XML declaration containing an encoding.
    - silence -- A boolean.  If False, export the object.
    Returns -- The root object in the tree.
    '''
    parser = None
    rootNode= parsexmlstring_(inString, parser)
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'eSocial'
        rootClass = eSocial
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    return rootObj


def parseLiteral(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'eSocial'
        rootClass = eSocial
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from evtCS import *\n\n')
        sys.stdout.write('import evtCS as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "CanonicalizationMethodType",
    "DSAKeyValueType",
    "DigestMethodType",
    "KeyInfoType",
    "KeyValueType",
    "ManifestType",
    "ObjectType",
    "PGPDataType",
    "RSAKeyValueType",
    "ReferenceType",
    "RetrievalMethodType",
    "SPKIDataType",
    "SignatureMethodType",
    "SignaturePropertiesType",
    "SignaturePropertyType",
    "SignatureType",
    "SignatureValueType",
    "SignedInfoType",
    "TEmpregador",
    "TransformType",
    "TransformsType",
    "X509DataType",
    "X509IssuerSerialType",
    "basesAquisType",
    "basesAvNPortType",
    "basesComercType",
    "basesCpType",
    "basesRemunType",
    "dadosOpPortType",
    "eSocial",
    "evtCSType",
    "ideEstabType",
    "ideEventoType",
    "ideLotacaoType",
    "infoAtConcType",
    "infoCPSegType",
    "infoCRContribType",
    "infoCREstabType",
    "infoCSType",
    "infoComplObraType",
    "infoContribType",
    "infoEmprParcialType",
    "infoEstabType",
    "infoPJType",
    "infoSubstPatrOpPortType",
    "infoTercSuspType"
]
